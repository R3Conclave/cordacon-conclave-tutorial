{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Conclave \u00b6 Conclave is a toolkit for building enclaves , small pieces of software that are protected from attack by the owner of the computer on which they run. It is ideally suited to solving multi-party collaboration and privacy problems. Why Conclave? \u00b6 Write your host app in any language that can run on a Java Virtual Machine. Write your enclave using the GraalVM native image technology for incredibly tight memory usage, support for any GraalVM language and instant startup time. Eliminate all memory management errors that would undermine the security of your enclave, thanks to the built-in generational garbage collector. High level, simple API that is much easier to use than other enclave APIs. Full support for auditing enclaves over the internet, including remote attestation and fully deterministic, reproducible builds. A user can verify what the source code of the remotely running enclave is, to ensure it will behave as they expect. A Gradle plugin to automate compiling, signing and calculating the code hash of your enclave. No need to use the Intel SDK - everything needed is included. API designs that guide you towards SGX best practices and avoidance of security pitfalls. A powerful unit testing framework to verify the operation of your enclave and remote attestation functionality, using just JUnit. Tutorials, guides and commercial support from the SGX experts at R3. Documentation \u00b6 Enclaves. If you're totally new to enclave development, start with our introduction to enclave-oriented design. This will explain the concepts referred to in the rest of the documentation. Architectural overview. This explains the core Conclave APIs. Tutorial. Once you understand the concepts go straight to writing your first enclave. Machine setup. Learn how to obtain SGX capable hardware, set it up, deploy to production and then keep your machine trusted by applying updates. Reference guide. We provide detailed JavaDocs for the API. Get in touch \u00b6 There's a public mailing list for discussion of using Conclave and SGX. Join conclave-discuss@groups.io . You can also email us directly . In future R3 will offer ticket based commercial support. Warning This is a developer preview release of Conclave. You may not run enclaves built with it in production. Please read the list of known issues . Release notes \u00b6 Beta 4 \u00b6 New feature! Conclave now supports building GraaalVM Native Image enclaves on macOS and Windows! GraaalVM Native Image support was added in Beta 3 but required a Linux build system. Now, by installing Docker on Windows or macOS you can configure your enclaves to use the graalvm_native_image runtime and let Conclave simply manage the build process for you. New feature! Conclave now supports DCAP along with EPID attestation. NOTE: This breaks compatibility with previous versions. Beta 3 \u00b6 New feature! The Mail API makes it easy to deliver encrypted messages to the enclave that only it can read, with sequencing and separation of different mail streams by topic. Mail can also be used by an enclave to persist (sealed) data. Learn more New feature! You can now compile your entire enclave ahead of time using GraaalVM Native Image . This gives you access to a much better JVM than in prior releases, with faster enclaves that use less RAM. The performance improvement can be between 4x and 12x faster than in prior releases and memory usage can be up to 5x lower. New feature! New mock API for easy debugging between the host and enclave, fast unit testing and easy development of enclaves on machines that don't support the technology. Learn more . New feature! You can now produce enclaves on macOS! Just follow the instructions as you would on a Linux developer machine, and a JAR with an embedded Linux enclave .so file will be produced automatically. You can then take that JAR and upload it to a Linux host for execution, e.g. via a Docker or webapp container (e.g. Tomcat). Combined with the equivalent Windows support we added in beta 2 and the easy to use mock enclave API, this completes our developer platform support and allows mixed teams of people working on their preferred OS to build enclave-oriented apps together. Please note: at this time only the Avian runtime can be cross-compiled from Windows and macOS. New feature! You may now make concurrent calls into the enclave using multiple threads,. Remote attestations (serialized EnclaveInstanceInfo objects) now remain valid across enclave restarts. They may still be invalidated by changes to the SGX TCB, for example, microcode updates applied as part of an operating system upgrade. Enclave/host communication now handles exceptions thrown across the boundary properly. In order to prevent accidental leakage of information from inside enclaves, release builds of enclaves no longer propagate console output across the enclave boundary. Calls to System.out.println() and related methods will now only print to the console on simulation and debug builds of enclaves. Beta 2 \u00b6 New feature! Build enclaves on Windows without any special emulators, virtual machines or other setup. New feature! Specify an enclave's product ID and revocation level in the enclave build file. There's a new conclave block which lets you do this. These values are enforced in any relevant EnclaveConstraint object. New feature! A new EnclaveHost.checkPlatformSupportsEnclaves API allows you to probe the host operating system to check if enclaves are loadable, before you try to actually do so. Additionally, if SGX is disabled in the BIOS but can be enabled by software request, Conclave can now do this for you. If the host machine needs extra configuration a useful error message is now provided in the exception. New feature! Better support for enclave signing in the Gradle plugin. New documentation has been added showing how to sign with externally managed keys. You can now use the Conclave host API from Java 11. The version of Java inside the enclave remains at Java 8. We've upgraded to use the version 2.9.1 of the Intel SGX SDK, which brings security improvements and lays the groundwork for new features. Make sure your host system is also running version 2.9.1. We've also upgraded to the latest version of the Intel Attestation Service (IAS). The ID for the enclave plugin is now com.r3.conclave.enclave . You will need to change this in your enclave's build.gradle file. enclave.xml files are no longer needed. You can safely delete them, as they're now generated for you by Conclave. The enclave measurement is now stable when built using different versions of the JDK. The format of an EnclaveInstanceInfo has been optimised. Old EnclaveInstanceInfo objects won't work with the beta 2 client libraries and vice-versa. Java serialization is now formally blocked inside the enclave using a filter. Unfiltered deserialization has a history of leading to exploits in programs written in high level managed languages.","title":"Welcome"},{"location":"index.html#conclave","text":"Conclave is a toolkit for building enclaves , small pieces of software that are protected from attack by the owner of the computer on which they run. It is ideally suited to solving multi-party collaboration and privacy problems.","title":"Conclave"},{"location":"index.html#why-conclave","text":"Write your host app in any language that can run on a Java Virtual Machine. Write your enclave using the GraalVM native image technology for incredibly tight memory usage, support for any GraalVM language and instant startup time. Eliminate all memory management errors that would undermine the security of your enclave, thanks to the built-in generational garbage collector. High level, simple API that is much easier to use than other enclave APIs. Full support for auditing enclaves over the internet, including remote attestation and fully deterministic, reproducible builds. A user can verify what the source code of the remotely running enclave is, to ensure it will behave as they expect. A Gradle plugin to automate compiling, signing and calculating the code hash of your enclave. No need to use the Intel SDK - everything needed is included. API designs that guide you towards SGX best practices and avoidance of security pitfalls. A powerful unit testing framework to verify the operation of your enclave and remote attestation functionality, using just JUnit. Tutorials, guides and commercial support from the SGX experts at R3.","title":"Why Conclave?"},{"location":"index.html#documentation","text":"Enclaves. If you're totally new to enclave development, start with our introduction to enclave-oriented design. This will explain the concepts referred to in the rest of the documentation. Architectural overview. This explains the core Conclave APIs. Tutorial. Once you understand the concepts go straight to writing your first enclave. Machine setup. Learn how to obtain SGX capable hardware, set it up, deploy to production and then keep your machine trusted by applying updates. Reference guide. We provide detailed JavaDocs for the API.","title":"Documentation"},{"location":"index.html#get-in-touch","text":"There's a public mailing list for discussion of using Conclave and SGX. Join conclave-discuss@groups.io . You can also email us directly . In future R3 will offer ticket based commercial support. Warning This is a developer preview release of Conclave. You may not run enclaves built with it in production. Please read the list of known issues .","title":"Get in touch"},{"location":"index.html#release-notes","text":"","title":"Release notes"},{"location":"index.html#beta-4","text":"New feature! Conclave now supports building GraaalVM Native Image enclaves on macOS and Windows! GraaalVM Native Image support was added in Beta 3 but required a Linux build system. Now, by installing Docker on Windows or macOS you can configure your enclaves to use the graalvm_native_image runtime and let Conclave simply manage the build process for you. New feature! Conclave now supports DCAP along with EPID attestation. NOTE: This breaks compatibility with previous versions.","title":"Beta 4"},{"location":"index.html#beta-3","text":"New feature! The Mail API makes it easy to deliver encrypted messages to the enclave that only it can read, with sequencing and separation of different mail streams by topic. Mail can also be used by an enclave to persist (sealed) data. Learn more New feature! You can now compile your entire enclave ahead of time using GraaalVM Native Image . This gives you access to a much better JVM than in prior releases, with faster enclaves that use less RAM. The performance improvement can be between 4x and 12x faster than in prior releases and memory usage can be up to 5x lower. New feature! New mock API for easy debugging between the host and enclave, fast unit testing and easy development of enclaves on machines that don't support the technology. Learn more . New feature! You can now produce enclaves on macOS! Just follow the instructions as you would on a Linux developer machine, and a JAR with an embedded Linux enclave .so file will be produced automatically. You can then take that JAR and upload it to a Linux host for execution, e.g. via a Docker or webapp container (e.g. Tomcat). Combined with the equivalent Windows support we added in beta 2 and the easy to use mock enclave API, this completes our developer platform support and allows mixed teams of people working on their preferred OS to build enclave-oriented apps together. Please note: at this time only the Avian runtime can be cross-compiled from Windows and macOS. New feature! You may now make concurrent calls into the enclave using multiple threads,. Remote attestations (serialized EnclaveInstanceInfo objects) now remain valid across enclave restarts. They may still be invalidated by changes to the SGX TCB, for example, microcode updates applied as part of an operating system upgrade. Enclave/host communication now handles exceptions thrown across the boundary properly. In order to prevent accidental leakage of information from inside enclaves, release builds of enclaves no longer propagate console output across the enclave boundary. Calls to System.out.println() and related methods will now only print to the console on simulation and debug builds of enclaves.","title":"Beta 3"},{"location":"index.html#beta-2","text":"New feature! Build enclaves on Windows without any special emulators, virtual machines or other setup. New feature! Specify an enclave's product ID and revocation level in the enclave build file. There's a new conclave block which lets you do this. These values are enforced in any relevant EnclaveConstraint object. New feature! A new EnclaveHost.checkPlatformSupportsEnclaves API allows you to probe the host operating system to check if enclaves are loadable, before you try to actually do so. Additionally, if SGX is disabled in the BIOS but can be enabled by software request, Conclave can now do this for you. If the host machine needs extra configuration a useful error message is now provided in the exception. New feature! Better support for enclave signing in the Gradle plugin. New documentation has been added showing how to sign with externally managed keys. You can now use the Conclave host API from Java 11. The version of Java inside the enclave remains at Java 8. We've upgraded to use the version 2.9.1 of the Intel SGX SDK, which brings security improvements and lays the groundwork for new features. Make sure your host system is also running version 2.9.1. We've also upgraded to the latest version of the Intel Attestation Service (IAS). The ID for the enclave plugin is now com.r3.conclave.enclave . You will need to change this in your enclave's build.gradle file. enclave.xml files are no longer needed. You can safely delete them, as they're now generated for you by Conclave. The enclave measurement is now stable when built using different versions of the JDK. The format of an EnclaveInstanceInfo has been optimised. Old EnclaveInstanceInfo objects won't work with the beta 2 client libraries and vice-versa. Java serialization is now formally blocked inside the enclave using a filter. Unfiltered deserialization has a history of leading to exploits in programs written in high level managed languages.","title":"Beta 2"},{"location":"architecture.html","text":"Architecture overview \u00b6 Primary entities \u00b6 There are three entities in an application that uses Conclave: Enclaves Hosts Clients Clients send and receive encrypted messages to/from enclaves by interacting with the host over the network. Conclave doesn't mandate any particular network protocol for client<->host communication. It's up to you. However the content of the messages is defined, using the Mail API. Mail is described below. Host programs load enclaves. From a security perspective they are fully untrusted and assumed to be malicious at all times. Hosts are relied on to provide the enclave with resources but beyond that work only with encrypted data. In some kinds of app their function is primarily proxying communications from clients to enclaves, but sometimes they also assist with application logic. Hosts use a standard JVM like HotSpot. Enclaves are classes that are loaded into a dedicated sub-JVM with a protected memory space, running inside the same operating system process as the host JVM. Because they don't share heaps the host may exchange only byte buffers with the enclave. Direct method calls also don't work out of the box: that would require you to add some sort of RPC system on top. In this way it's similar to interacting with a server over a network, except the enclave is fully local. In the above diagram orange shaded boxes are untrusted and could attack the enclave: the host and operating system (which includes the BIOS, drivers and peripherals). Blue shaded boxes are part of the trusted computing base - the set of components that must be correct and non-malicious for the system to work. That includes the enclave and of course the CPU. The client communicates with the enclave via the host. Both client and host interact with Intel servers to obtain relevant pieces of data proving the CPU is genuine and considered secure (see below for more information on this process). The enclave has a complex interaction with both operating system and host, in which the OS schedules the enclave onto the CPU and provides resources but is otherwise locked out of the enclave's operation. For its part, the enclave cannot interact with the OS directly and runs in what is effectively a \"bare metal\" embedded style environment. It cannot load DLLs/.so files or do system calls, so there's no way for it to do things like load files directly. It must ask the host to do it and use cryptography to prevent the malicious host from tampering with the data as it's loaded or saved. Notice Because the enclave runtime environment isn't the same as a normal HotSpot JVM, you will need to test your enclave code carefully and avoid advanced features that the embedded JVM doesn't support, such as Java Flight Recorder. Remote attestation \u00b6 To use an enclave, clients need to know the network address where the host process for an enclave instance is running so they can send it messages, and they also need to obtain an EnclaveInstanceInfo object from the host. This could be downloaded on demand from the host, or it could be published somewhere. This object encapsulates a remote attestation . The client tests the EnclaveInstanceInfo against a set of constraints, depending on how flexible they want to be about software upgrades to the enclave. Constraints are represented by an EnclaveConstraint object, which can be read from/written to a small domain specific language suitable for embedding in config files, command line options and so on. A constraint may specify that a specific set of code hashes is required i.e. every version is whitelisted and no upgrade is possible until the constraint is adjusted. Or, it may specify a set of allowed signing keys, enabling enclave authors to release new versions whenever they want. In that scenario the enclave creator is trusted, but the entity hosting the enclave instance may not be. When they're happy, they create encrypted messages using the key in the EnclaveInstanceInfo . By sending and receiving such messages to the host (and from there to the enclave), communication is established. See the Mail section below for further discussion of this. Whilst the high level setup has just those three entities, real deployments have more: Intel Optionally, a cloud provider Optionally, an auditor Intel. Intel's involvement in a deployed architecture is limited to providing the CPU hardware and running some servers. These servers provision the host with certificates guaranteeing authenticity of the chip (once, on initial setup) and provide the client with an assessment of the security of the host given a remote attestation (whenever the client requests it). If Intel's servers become unreachable by the clients that's not a problem, it just means the security of the host machine may degrade without the clients realising. For instance if host's SGX software stack is out of date and has known vulnerabilities, or if the BIOS configuration is not correct, this will be reported to the client by Intel's servers as part of verifying and processing the data inside the remote attestation provided by the client. Cloud provider. A cloud provider needs to support SGX for Conclave to be usable. They may operate their own provisioning servers that take over from Intel's. Notice Cloud providers running their own provisioning servers is a new feature of SGX and not yet supported by Conclave. Auditor. In the pure enclave-oriented model, the user is responsible for understanding what the enclave does before using it by reading the enclave's source code. If the user doesn't do this then enclaves have no point. In practice the user may wish to outsource this auditing to someone else. Protocol sequence diagram \u00b6 This is what a typical interaction looks like: The first time SGX is used on a machine there are interactions with either the cloud provider or Intel to retrieve machine certificates proving authenticity. The host then gets a remote attestation ( EnclaveInstanceInfo ) to the client somehow, the client verifies it and optionally asks Intel if the hardware setup of the machine is still considered to be secure, or if there are known vulnerabilities (see renewability ). This can be repeated as often as the client wants, e.g. every day. Once this is done the client can send messages to the enclave through the host. Mail \u00b6 Communicating with an enclave requires sending and receiving encrypted and authenticated messages. One possible approach is to embed a TLS stack into the enclave and use something like HTTPS, but this technique has some problems and limitations that are resolved via the Conclave Mail API . Mail makes communication between enclaves and clients easy, as well as solving common problems faced with doing application development. Testing and debugging \u00b6 Conclave provides full unit testing support for enclaves. Enclaves themselves can be compiled for one of three modes: Production/release : fully encrypted and protected memory. Debug : the same as production, but special instructions are provided that allow enclave memory to be read and modified. This mode provides no protection but is otherwise a faithful recreation of the standard environment. Simulation : SGX hardware isn't actually used at all. This is helpful during development when SGX capable hardware may not be available. The modes must match between how the enclave was compiled and how it's loaded. This is handled for you automatically. Inside the enclave System.out and System.err are wired up to the host console, but logging to files doesn't work. This is to avoid accidentally leaking private data to the host via logging. Notice Future versions of the platform may offer encrypted logging of various forms. Virtual machines and performance \u00b6 Enclave code can run on one of two different virtual machines. Both can execute JVM bytecode. One is a small, specialised runtime called Avian. Avian is slow but can dynamically load bytecode, which some Java frameworks like to do. The other is GraalVM Native Image (SubstrateVM). The latter compiles your entire program to native code ahead of time, erasing any code that isn't used and optimising it as a whole. This can yield large speedups and memory usage improvements, at the cost of being unable to dynamically load new classes. The differences between the two runtimes is summarised by the table below: Avian JVM GraalVM Native Image Execute dynamic JVM code * Java 8 Support Java 9+ Support * * Dynamic JVM code execution and Java 9+ support using GraalVM Native Image is planned for a future release of Conclave. The speedups from using Native Image can be significant. However, as the enclave environment is small the performance will still be lower than with a regular HotSpot JVM. This table shows the performance difference and how they vary between a variety of benchmarks taken from the Computer Language Benchmarks Game . Note The \"empty\" benchmark is measuring the overhead of entering and exiting the enclave, without doing any work. As entering/exiting triggers a variety of hardware mechanisms designed to block side channel attacks this is naturally expensive relative to the cost of a regular function call, however, once the enclave is doing real work this transition cost becomes less relevant. Benchmark Runtime Score Error Units empty Avian 15970.313 \u00b1 837.783 ops/s empty GraalVM 51921.076 \u00b1 1697.024 ops/s empty HotSpot 49453365.793 \u00b1 3404118.758 ops/s binary_trees Avian 19.727 \u00b1 0.733 ops/s binary_trees GraalVM 454.061 \u00b1 31.089 ops/s binary_trees HotSpot 1758.980 \u00b1 79.428 ops/s fannkuch Avian 0.277 \u00b1 0.007 ops/s fannkuch GraalVM 4.181 \u00b1 0.024 ops/s fannkuch HotSpot 5.925 \u00b1 0.063 ops/s fasta Avian 1.692 \u00b1 0.010 ops/s fasta GraalVM 3.185 \u00b1 0.028 ops/s fasta HotSpot 4.022 \u00b1 0.127 ops/s himeno Avian 0.104 \u00b1 0.001 ops/s himeno GraalVM 0.179 \u00b1 0.004 ops/s himeno HotSpot 0.366 \u00b1 0.003 ops/s mandelbrot Avian 1.855 \u00b1 0.861 ops/s mandelbrot GraalVM 5.529 \u00b1 0.134 ops/s mandelbrot HotSpot 6.385 \u00b1 0.132 ops/s nbody Avian 0.359 \u00b1 0.004 ops/s nbody GraalVM 1.205 \u00b1 0.021 ops/s nbody HotSpot 1.279 \u00b1 0.017 ops/s pidigits Avian 0.747 \u00b1 0.020 ops/s pidigits GraalVM 9.941 \u00b1 0.185 ops/s pidigits HotSpot 24.722 \u00b1 0.301 ops/s spectral_norm Avian 2.819 \u00b1 1.076 ops/s spectral_norm GraalVM 11.923 \u00b1 0.274 ops/s spectral_norm HotSpot 17.345 \u00b1 0.930 ops/s Higher scores are better. As you can see, GraalVM based enclaves are around 4x-12x faster than with Avian, depending on the task. The performance hit overall of using an enclave is also highly dependent on what exactly the code is doing (primarily, memory access patterns).","title":"Architecture"},{"location":"architecture.html#architecture-overview","text":"","title":"Architecture overview"},{"location":"architecture.html#primary-entities","text":"There are three entities in an application that uses Conclave: Enclaves Hosts Clients Clients send and receive encrypted messages to/from enclaves by interacting with the host over the network. Conclave doesn't mandate any particular network protocol for client<->host communication. It's up to you. However the content of the messages is defined, using the Mail API. Mail is described below. Host programs load enclaves. From a security perspective they are fully untrusted and assumed to be malicious at all times. Hosts are relied on to provide the enclave with resources but beyond that work only with encrypted data. In some kinds of app their function is primarily proxying communications from clients to enclaves, but sometimes they also assist with application logic. Hosts use a standard JVM like HotSpot. Enclaves are classes that are loaded into a dedicated sub-JVM with a protected memory space, running inside the same operating system process as the host JVM. Because they don't share heaps the host may exchange only byte buffers with the enclave. Direct method calls also don't work out of the box: that would require you to add some sort of RPC system on top. In this way it's similar to interacting with a server over a network, except the enclave is fully local. In the above diagram orange shaded boxes are untrusted and could attack the enclave: the host and operating system (which includes the BIOS, drivers and peripherals). Blue shaded boxes are part of the trusted computing base - the set of components that must be correct and non-malicious for the system to work. That includes the enclave and of course the CPU. The client communicates with the enclave via the host. Both client and host interact with Intel servers to obtain relevant pieces of data proving the CPU is genuine and considered secure (see below for more information on this process). The enclave has a complex interaction with both operating system and host, in which the OS schedules the enclave onto the CPU and provides resources but is otherwise locked out of the enclave's operation. For its part, the enclave cannot interact with the OS directly and runs in what is effectively a \"bare metal\" embedded style environment. It cannot load DLLs/.so files or do system calls, so there's no way for it to do things like load files directly. It must ask the host to do it and use cryptography to prevent the malicious host from tampering with the data as it's loaded or saved. Notice Because the enclave runtime environment isn't the same as a normal HotSpot JVM, you will need to test your enclave code carefully and avoid advanced features that the embedded JVM doesn't support, such as Java Flight Recorder.","title":"Primary entities"},{"location":"architecture.html#remote-attestation","text":"To use an enclave, clients need to know the network address where the host process for an enclave instance is running so they can send it messages, and they also need to obtain an EnclaveInstanceInfo object from the host. This could be downloaded on demand from the host, or it could be published somewhere. This object encapsulates a remote attestation . The client tests the EnclaveInstanceInfo against a set of constraints, depending on how flexible they want to be about software upgrades to the enclave. Constraints are represented by an EnclaveConstraint object, which can be read from/written to a small domain specific language suitable for embedding in config files, command line options and so on. A constraint may specify that a specific set of code hashes is required i.e. every version is whitelisted and no upgrade is possible until the constraint is adjusted. Or, it may specify a set of allowed signing keys, enabling enclave authors to release new versions whenever they want. In that scenario the enclave creator is trusted, but the entity hosting the enclave instance may not be. When they're happy, they create encrypted messages using the key in the EnclaveInstanceInfo . By sending and receiving such messages to the host (and from there to the enclave), communication is established. See the Mail section below for further discussion of this. Whilst the high level setup has just those three entities, real deployments have more: Intel Optionally, a cloud provider Optionally, an auditor Intel. Intel's involvement in a deployed architecture is limited to providing the CPU hardware and running some servers. These servers provision the host with certificates guaranteeing authenticity of the chip (once, on initial setup) and provide the client with an assessment of the security of the host given a remote attestation (whenever the client requests it). If Intel's servers become unreachable by the clients that's not a problem, it just means the security of the host machine may degrade without the clients realising. For instance if host's SGX software stack is out of date and has known vulnerabilities, or if the BIOS configuration is not correct, this will be reported to the client by Intel's servers as part of verifying and processing the data inside the remote attestation provided by the client. Cloud provider. A cloud provider needs to support SGX for Conclave to be usable. They may operate their own provisioning servers that take over from Intel's. Notice Cloud providers running their own provisioning servers is a new feature of SGX and not yet supported by Conclave. Auditor. In the pure enclave-oriented model, the user is responsible for understanding what the enclave does before using it by reading the enclave's source code. If the user doesn't do this then enclaves have no point. In practice the user may wish to outsource this auditing to someone else.","title":"Remote attestation"},{"location":"architecture.html#protocol-sequence-diagram","text":"This is what a typical interaction looks like: The first time SGX is used on a machine there are interactions with either the cloud provider or Intel to retrieve machine certificates proving authenticity. The host then gets a remote attestation ( EnclaveInstanceInfo ) to the client somehow, the client verifies it and optionally asks Intel if the hardware setup of the machine is still considered to be secure, or if there are known vulnerabilities (see renewability ). This can be repeated as often as the client wants, e.g. every day. Once this is done the client can send messages to the enclave through the host.","title":"Protocol sequence diagram"},{"location":"architecture.html#mail","text":"Communicating with an enclave requires sending and receiving encrypted and authenticated messages. One possible approach is to embed a TLS stack into the enclave and use something like HTTPS, but this technique has some problems and limitations that are resolved via the Conclave Mail API . Mail makes communication between enclaves and clients easy, as well as solving common problems faced with doing application development.","title":"Mail"},{"location":"architecture.html#testing-and-debugging","text":"Conclave provides full unit testing support for enclaves. Enclaves themselves can be compiled for one of three modes: Production/release : fully encrypted and protected memory. Debug : the same as production, but special instructions are provided that allow enclave memory to be read and modified. This mode provides no protection but is otherwise a faithful recreation of the standard environment. Simulation : SGX hardware isn't actually used at all. This is helpful during development when SGX capable hardware may not be available. The modes must match between how the enclave was compiled and how it's loaded. This is handled for you automatically. Inside the enclave System.out and System.err are wired up to the host console, but logging to files doesn't work. This is to avoid accidentally leaking private data to the host via logging. Notice Future versions of the platform may offer encrypted logging of various forms.","title":"Testing and debugging"},{"location":"architecture.html#virtual-machines-and-performance","text":"Enclave code can run on one of two different virtual machines. Both can execute JVM bytecode. One is a small, specialised runtime called Avian. Avian is slow but can dynamically load bytecode, which some Java frameworks like to do. The other is GraalVM Native Image (SubstrateVM). The latter compiles your entire program to native code ahead of time, erasing any code that isn't used and optimising it as a whole. This can yield large speedups and memory usage improvements, at the cost of being unable to dynamically load new classes. The differences between the two runtimes is summarised by the table below: Avian JVM GraalVM Native Image Execute dynamic JVM code * Java 8 Support Java 9+ Support * * Dynamic JVM code execution and Java 9+ support using GraalVM Native Image is planned for a future release of Conclave. The speedups from using Native Image can be significant. However, as the enclave environment is small the performance will still be lower than with a regular HotSpot JVM. This table shows the performance difference and how they vary between a variety of benchmarks taken from the Computer Language Benchmarks Game . Note The \"empty\" benchmark is measuring the overhead of entering and exiting the enclave, without doing any work. As entering/exiting triggers a variety of hardware mechanisms designed to block side channel attacks this is naturally expensive relative to the cost of a regular function call, however, once the enclave is doing real work this transition cost becomes less relevant. Benchmark Runtime Score Error Units empty Avian 15970.313 \u00b1 837.783 ops/s empty GraalVM 51921.076 \u00b1 1697.024 ops/s empty HotSpot 49453365.793 \u00b1 3404118.758 ops/s binary_trees Avian 19.727 \u00b1 0.733 ops/s binary_trees GraalVM 454.061 \u00b1 31.089 ops/s binary_trees HotSpot 1758.980 \u00b1 79.428 ops/s fannkuch Avian 0.277 \u00b1 0.007 ops/s fannkuch GraalVM 4.181 \u00b1 0.024 ops/s fannkuch HotSpot 5.925 \u00b1 0.063 ops/s fasta Avian 1.692 \u00b1 0.010 ops/s fasta GraalVM 3.185 \u00b1 0.028 ops/s fasta HotSpot 4.022 \u00b1 0.127 ops/s himeno Avian 0.104 \u00b1 0.001 ops/s himeno GraalVM 0.179 \u00b1 0.004 ops/s himeno HotSpot 0.366 \u00b1 0.003 ops/s mandelbrot Avian 1.855 \u00b1 0.861 ops/s mandelbrot GraalVM 5.529 \u00b1 0.134 ops/s mandelbrot HotSpot 6.385 \u00b1 0.132 ops/s nbody Avian 0.359 \u00b1 0.004 ops/s nbody GraalVM 1.205 \u00b1 0.021 ops/s nbody HotSpot 1.279 \u00b1 0.017 ops/s pidigits Avian 0.747 \u00b1 0.020 ops/s pidigits GraalVM 9.941 \u00b1 0.185 ops/s pidigits HotSpot 24.722 \u00b1 0.301 ops/s spectral_norm Avian 2.819 \u00b1 1.076 ops/s spectral_norm GraalVM 11.923 \u00b1 0.274 ops/s spectral_norm HotSpot 17.345 \u00b1 0.930 ops/s Higher scores are better. As you can see, GraalVM based enclaves are around 4x-12x faster than with Avian, depending on the task. The performance hit overall of using an enclave is also highly dependent on what exactly the code is doing (primarily, memory access patterns).","title":"Virtual machines and performance"},{"location":"dcap.html","text":"","title":"Dcap"},{"location":"enclaves.html","text":"Enclave oriented computing \u00b6 Conclave implements the latest iteration of a simple idea: we can make computing more secure and private by isolating a small piece of code from the rest of the computer on which it runs (an enclave ). Remote users can be shown what code is running in the isolated world and then upload secrets to it, where they can be processed without the owner of the computer in question getting access to them. Enclaves can be used to protect private data from the cloud, do multi-party computations on shared datasets and make networks more secure. Intel SGX is an implementation of enclave-oriented computing. Conclave builds on SGX by making it easier to develop enclaves in high level languages like Java or Kotlin. In this document we'll introduce the key concepts. What is an enclave? \u00b6 An enclave is a region of memory which the CPU blocks access to, running inside an ordinary process which we call the host . The region contains both code and data, neither of which can be read or tampered with by anything else. Code executing inside this region has access to special CPU instructions that give it a variety of useful abilities. Enclave memory is protected both from the rest of the code in that process, privileged software like the kernel or BIOS, and because the RAM itself is encrypted even physical attackers. This means a remote computer can trust that an enclave will operate correctly even if the owner of the computer is malicious. In Conclave, an enclave is a subclass of the Enclave class, combined with an embedded JVM and compiled into a native shared library (ending in .so), which is then itself bundled into the module JAR. The host program then uses the EnclaveHost class to load the enclave class. Local messaging and operating system access \u00b6 Once an enclave is loaded, the host and enclave can exchange byte buffers back and forth. The format of these byte arrays isn't defined by Conclave and is up to the application developer. The actual call operation is efficient: the buffers are copied from the host into the enclave using a direct memory copy. There are no sockets or other operating system constructs involved. Enclaves can't directly access the operating system. However, they can request the host process to do the access on the enclave's behalf. In practice due to the untrusted nature of the host operating system, it is much safer to make explicit requests to the host than try to run existing code inside the enclave. Most existing software is built on the assumption that the operating system is not a threat , because the OS normally has complete control so it doesn't make sense to defend yourself from it. Encrypted messages \u00b6 Enclaves are only useful if some other computer is interacting with them over the network. An enclave by itself doesn't gain you anything, because enclaves are defending against the owner of a computer. If you just run an enclave locally then the owner of the computer is you, and it doesn't make sense for software to try and protect your own data from yourself. Enclaves can generate random numbers and thus encryption keys available only to themselves, which nothing else on the host machine can access. Using these keys remote computers can encrypt messages to the enclave. These messages can be passed into the enclave via the host where they are decrypted and worked on. The owner of the host computer can't read them, despite that the data is being processed on their hardware. Conclave calls these encrypted messages mails , by way of analogy to encrypted e-mail, but enclaves can work with encryption in whatever way they want. The Mail API is just a utility and you don't have to use it. Remote attestation \u00b6 Encrypting a message requires a public key, which raises the question of where that key comes from. The clients of the enclave have to be convinced that the key really belongs to an enclave they want to work with and not, say, an unencrypted non-enclave program that's impersonating the intended destination. Enclave host programs can generate a small data structure called a remote attestation (RA). This structure states the following facts: A genuine, un-revoked Intel CPU is running ... ... an enclave into which a code module with a specific hash (measurement) was loaded ... ... and which has generated public key P ... ... and the computer is up to date with security patches, and configured in the recommended way. The host generates a remote attestation and sends it to clients in some way. Those clients can then send encrypted messages to the enclave using the public key P after checking what kind of enclave it really is. By recognising a list of known code hashes clients can effectively whitelist particular enclaves and treat them as trustworthy servers. In Conclave, a remote attestation is an instance of the EnclaveInstanceInfo class. Measurements vs signers \u00b6 The code hash included in a remote attestation is called a measurement . It's not the hash of any particular file but rather a more complex hash that must be calculated with special tools. It covers the entire module and all of its dependencies loaded into an enclave (a fat JAR). A measurement hash is pretty unhelpful by itself. It's just a large number. To be meaningful you must reproduce the measurement from the source code of the enclave. With Conclave this is easy as we've fixed everything that might cause two different builds of the same source code to yield a different file. When you compile your enclave the measurement hash is calculated and printed. By comparing it to what you find inside a remote attestation, you can know the source code of the remote enclave matches what you have locally. Whitelisting measurements is strong but brittle. Any upgrade to the enclave will cause your app to reject the new remote attestation and stop working until you re-read the enclave's source code, reproduce the build again and whitelist the new measurement. An alternative is to whitelist a signing key instead. Enclave files can be signed, and the SGX infrastructure understands and verifies these signatures. This is useful for two reasons: You can choose to accept any enclave produced by a particular organisation, rather than reviewing the source code and reproducing the enclave yourself. Each SGX capable computer has a root key that must whitelist enclaves to be executed. This is so cloud providers can retain visibility and control into what programs are actually running on their hardware. The public part of the key that signed an enclave is included in remote attestations, so you can choose to communicate with any enclave signed by a given key. Small is beautiful \u00b6 Enclaves are a very general capability and can be used in a variety of ways. You can: Process private data without being able to see it yourself, to enhance your user's privacy. Create a hardware-backed form of zero knowledge proofs: make trustworthy 'statements' that a particular computation was done on some data, without the data itself needing to be revealed. Outsource some kinds of computations to an untrusted cloud. Improve the security of a server by restricting access to a whitelist of client enclaves, blocking attempts to send malformed packets and messages that might come from hackers. Make your service auditable only by users who want high assurance - those who don't care can simply ignore the infrastructure entirely. It's important to understand the limitations of enclaves. They aren't meant to be a general protection for arbitrary programs. Although technically possible to just relay operating system calls in and out of an enclave, this approach suffers from various security pitfalls and more importantly is a mis-understanding of the benefits enclaves give you. Enclave-oriented computing is based on two key insights: The more code that processes attacker-supplied data the more likely the program is to be hackable. A large chunk of most programs is actually just moving data around and managing it in various ways, not processing it. The software and hardware that must be uncompromised for a system to work correctly is called the trusted computing base , or TCB. In Conclave the TCB includes the CPU itself, the patchable microcode of the CPU, and all software running inside the enclave - both your code and the Conclave runtime. A major goal in secure systems design is to minimise the size of the TCB. This is for two reasons. Security \u00b6 The software industry has decades of experience with building secure and tamperproof systems. A simple heuristic is that the more code there is inside the TCB that handles attacker-controlled data, the easier it will be for an adversary to find a mistake and break in. It's always been good design to minimise the amount of code that handles potentially malicious data and enclaves give you an even greater incentive to do so. That's because enclaves don't magically make the software inside them un-hackable. They protect the code and its memory from outside interference by the owner of the computer (and any hackers that gained access to the operating system) but if the code running inside the enclave has a bug that can be used to get in those protections are of no use. Thus it's important for an enclave to be written securely. Conclave helps with this dramatically because it lets you write enclave logic in memory-safe, type-safe languages like Java or Kotlin. These languages eliminate by construction huge swathes of bugs. All buffer bounds are checked, no memory is freed before use and all casts are valid. This makes it much easier to process data from outside the enclave because you don't have to worry that you might accidentally let an attacker in. Sometimes people find this confusing: a JVM is quite large, so if the TCB needs to be small isn't that a problem? It's not for two reasons. One reason is because this heuristic only applies for code that an attacker can actually reach and influence via external input, but the input data to the JVM (bytecode) is itself a fixed part of the enclave. Attackers can't modify it without changing the measurement reported in the remote attestation and thus being detected by the client - the client's enclave constraint will be violated and an exception will be thrown. The second reason is that Conclave uses the GraalVM Native Image JVM, in which all bytecode is compiled to native code ahead of time. The actual JVM in use is therefore quite tiny; it consists mostly of the garbage collector. Warning Whilst garbage collected/type safe programs are much safer than programs written in C, they aren't immune to vulnerabilities. Watch out for very generic reflective code like object serialization frameworks, that could be tricked into deserializing malicious streams. Auditability \u00b6 Enclaves are meaningless unless the user verifies the enclave does what they think it does before sending it private data. As the enclave size goes up it gets harder to read and understand its code. In practice audit work will often be outsourced: we don't expect that every end user of an enclave reads all the code themselves. Ultimately though, someone the user trusts must read all the code inside the enclave. The less there is to read the better. A lot of code works with data without parsing or understanding it. For instance, network frameworks read packets from the wire and databases store data to disk in generic ways. Other parts of a program truly understand the data and work with it in app-specific ways; usually this is called business logic. In enclave-oriented design you draw a bright line between host code and business logic. Business logic runs inside an enclave on normal Java objects. Host code does everything else: Network handling Storage Routing Monitoring Providing administration interfaces and so on. Keeping as much code in the host as possible has two key advantages: The host code is untrusted and assumed to be compromised. Thus any bugs in it are much less serious. You can worry less about security vulnerabilities in the host code because it can't access your user's private data. Because the enclave is small it will change less frequently, meaning clients don't need to re-audit or whitelist new versions. The second point is intuitive to understand. Think of your enclave as a concrete version of your privacy policy. If you change your web server, core database engine or even entire operating system then this is of no concern to your users. You've only changed how data is processed. But if you change what you do with their data, they may have an opinion on this and want to know about it. Remote attestation lets them see that the core business logic has changed, and in what way. Enclaves vs alternative approaches \u00b6 The enclave architecture is the result of many years of evolution. Enclaves are good at minimising TCB size because that was their entire design goal: an enclave is intended to be the smallest piece of application logic that needs to be protected. Some other systems work by attempting to protect and attest an entire operating system stack, but this was tried in the past and found to work poorly. Let us now briefly trace the historical evolution that led to the SGX enclave design today. The first attempts at implementing trusted computing relied on a so-called trusted platform module chip (TPM). The TPM contained special registers called platform configuration registers (PCR). A PCR was sized to contain a hash, but could not be written directly. Instead writing to a PCR concatenated the new hash value with the prior, and stored the result of hashing that concatenation. PCRs therefore contained the final hash in a chain of hashes. The only way to get a PCR to a particular value is to feed it the right sequence of hashes, called the chain of trust . The firmware and electronics on the motherboard implemented a static root of trust . In this design, the initial boot ROM would load the BIOS and other firmware, hash it into a PCR and then pass control to it. The firmware would then in turn hash and load the next stage into the same PCR and so on. Thus by the time the system booted, all the software and firmware on the system had been hashed together. The contents of the PCR could then be remotely attested and the user could verify what software booted. This then let them reason about how the remote computer would behave. Given the explanations above the problem with this approach is hopefully now obvious - this approach defined the TCB as everything in the entire boot sequence, including the whole operating system kernel. Any bug at any point in this code would allow someone to create a forged chain of trust and undermine the system. But system firmware is already very large and likely to contain bugs, let alone a kernel. And even if the entire boot was secure the operating system or application server would likely contain bugs allowing in remote attackers anyway. On the open PC platform this system turned out to be too easy to defeat, and became abandoned outside of a few use cases involving disk encryption (with no remote attestation). Despite its failure in PCs, static roots of trust worked well enough for games consoles where the entire boot sequence could be encrypted, locked down, attested to multi-player game networks and very carefully audited by a vertically integrated systems manufacturer. The next attempt introduced a dynamic chain of trust via Intel TXT and AMD SVM. TXT/SVM provided so-called \"late launch\" in which a hypervisor can be started up and measured whilst the system is running. The hypervisor can then measure and boot an operating system, which may be a small and special purpose operating system. This approach also failed to gain much traction, as at the time building a small special purpose OS was too difficult (whereas nowadays open source unikernel operating systems are more easily available), and booting a regular Linux faced many of the same problems as with the static root of trust: too many places to hide back doors, too many bugs for the system to be truly trustworthy. This is how we arrived at SGX. An enclave runs in user-space and does not require a large piece of code like a hypervisor, kernel and system firmware to become a part of the remote attestation. Instead, only a small statically linked binary is loaded and protected. The code in the enclave can communicate with the host process by reading and writing from host memory. The TCB size is finally minimised to only what is strictly necessary - as long as your app is designed correctly.","title":"Enclaves"},{"location":"enclaves.html#enclave-oriented-computing","text":"Conclave implements the latest iteration of a simple idea: we can make computing more secure and private by isolating a small piece of code from the rest of the computer on which it runs (an enclave ). Remote users can be shown what code is running in the isolated world and then upload secrets to it, where they can be processed without the owner of the computer in question getting access to them. Enclaves can be used to protect private data from the cloud, do multi-party computations on shared datasets and make networks more secure. Intel SGX is an implementation of enclave-oriented computing. Conclave builds on SGX by making it easier to develop enclaves in high level languages like Java or Kotlin. In this document we'll introduce the key concepts.","title":"Enclave oriented computing"},{"location":"enclaves.html#what-is-an-enclave","text":"An enclave is a region of memory which the CPU blocks access to, running inside an ordinary process which we call the host . The region contains both code and data, neither of which can be read or tampered with by anything else. Code executing inside this region has access to special CPU instructions that give it a variety of useful abilities. Enclave memory is protected both from the rest of the code in that process, privileged software like the kernel or BIOS, and because the RAM itself is encrypted even physical attackers. This means a remote computer can trust that an enclave will operate correctly even if the owner of the computer is malicious. In Conclave, an enclave is a subclass of the Enclave class, combined with an embedded JVM and compiled into a native shared library (ending in .so), which is then itself bundled into the module JAR. The host program then uses the EnclaveHost class to load the enclave class.","title":"What is an enclave?"},{"location":"enclaves.html#local-messaging-and-operating-system-access","text":"Once an enclave is loaded, the host and enclave can exchange byte buffers back and forth. The format of these byte arrays isn't defined by Conclave and is up to the application developer. The actual call operation is efficient: the buffers are copied from the host into the enclave using a direct memory copy. There are no sockets or other operating system constructs involved. Enclaves can't directly access the operating system. However, they can request the host process to do the access on the enclave's behalf. In practice due to the untrusted nature of the host operating system, it is much safer to make explicit requests to the host than try to run existing code inside the enclave. Most existing software is built on the assumption that the operating system is not a threat , because the OS normally has complete control so it doesn't make sense to defend yourself from it.","title":"Local messaging and operating system access"},{"location":"enclaves.html#encrypted-messages","text":"Enclaves are only useful if some other computer is interacting with them over the network. An enclave by itself doesn't gain you anything, because enclaves are defending against the owner of a computer. If you just run an enclave locally then the owner of the computer is you, and it doesn't make sense for software to try and protect your own data from yourself. Enclaves can generate random numbers and thus encryption keys available only to themselves, which nothing else on the host machine can access. Using these keys remote computers can encrypt messages to the enclave. These messages can be passed into the enclave via the host where they are decrypted and worked on. The owner of the host computer can't read them, despite that the data is being processed on their hardware. Conclave calls these encrypted messages mails , by way of analogy to encrypted e-mail, but enclaves can work with encryption in whatever way they want. The Mail API is just a utility and you don't have to use it.","title":"Encrypted messages"},{"location":"enclaves.html#remote-attestation","text":"Encrypting a message requires a public key, which raises the question of where that key comes from. The clients of the enclave have to be convinced that the key really belongs to an enclave they want to work with and not, say, an unencrypted non-enclave program that's impersonating the intended destination. Enclave host programs can generate a small data structure called a remote attestation (RA). This structure states the following facts: A genuine, un-revoked Intel CPU is running ... ... an enclave into which a code module with a specific hash (measurement) was loaded ... ... and which has generated public key P ... ... and the computer is up to date with security patches, and configured in the recommended way. The host generates a remote attestation and sends it to clients in some way. Those clients can then send encrypted messages to the enclave using the public key P after checking what kind of enclave it really is. By recognising a list of known code hashes clients can effectively whitelist particular enclaves and treat them as trustworthy servers. In Conclave, a remote attestation is an instance of the EnclaveInstanceInfo class.","title":"Remote attestation"},{"location":"enclaves.html#measurements-vs-signers","text":"The code hash included in a remote attestation is called a measurement . It's not the hash of any particular file but rather a more complex hash that must be calculated with special tools. It covers the entire module and all of its dependencies loaded into an enclave (a fat JAR). A measurement hash is pretty unhelpful by itself. It's just a large number. To be meaningful you must reproduce the measurement from the source code of the enclave. With Conclave this is easy as we've fixed everything that might cause two different builds of the same source code to yield a different file. When you compile your enclave the measurement hash is calculated and printed. By comparing it to what you find inside a remote attestation, you can know the source code of the remote enclave matches what you have locally. Whitelisting measurements is strong but brittle. Any upgrade to the enclave will cause your app to reject the new remote attestation and stop working until you re-read the enclave's source code, reproduce the build again and whitelist the new measurement. An alternative is to whitelist a signing key instead. Enclave files can be signed, and the SGX infrastructure understands and verifies these signatures. This is useful for two reasons: You can choose to accept any enclave produced by a particular organisation, rather than reviewing the source code and reproducing the enclave yourself. Each SGX capable computer has a root key that must whitelist enclaves to be executed. This is so cloud providers can retain visibility and control into what programs are actually running on their hardware. The public part of the key that signed an enclave is included in remote attestations, so you can choose to communicate with any enclave signed by a given key.","title":"Measurements vs signers"},{"location":"enclaves.html#small-is-beautiful","text":"Enclaves are a very general capability and can be used in a variety of ways. You can: Process private data without being able to see it yourself, to enhance your user's privacy. Create a hardware-backed form of zero knowledge proofs: make trustworthy 'statements' that a particular computation was done on some data, without the data itself needing to be revealed. Outsource some kinds of computations to an untrusted cloud. Improve the security of a server by restricting access to a whitelist of client enclaves, blocking attempts to send malformed packets and messages that might come from hackers. Make your service auditable only by users who want high assurance - those who don't care can simply ignore the infrastructure entirely. It's important to understand the limitations of enclaves. They aren't meant to be a general protection for arbitrary programs. Although technically possible to just relay operating system calls in and out of an enclave, this approach suffers from various security pitfalls and more importantly is a mis-understanding of the benefits enclaves give you. Enclave-oriented computing is based on two key insights: The more code that processes attacker-supplied data the more likely the program is to be hackable. A large chunk of most programs is actually just moving data around and managing it in various ways, not processing it. The software and hardware that must be uncompromised for a system to work correctly is called the trusted computing base , or TCB. In Conclave the TCB includes the CPU itself, the patchable microcode of the CPU, and all software running inside the enclave - both your code and the Conclave runtime. A major goal in secure systems design is to minimise the size of the TCB. This is for two reasons.","title":"Small is beautiful"},{"location":"enclaves.html#security","text":"The software industry has decades of experience with building secure and tamperproof systems. A simple heuristic is that the more code there is inside the TCB that handles attacker-controlled data, the easier it will be for an adversary to find a mistake and break in. It's always been good design to minimise the amount of code that handles potentially malicious data and enclaves give you an even greater incentive to do so. That's because enclaves don't magically make the software inside them un-hackable. They protect the code and its memory from outside interference by the owner of the computer (and any hackers that gained access to the operating system) but if the code running inside the enclave has a bug that can be used to get in those protections are of no use. Thus it's important for an enclave to be written securely. Conclave helps with this dramatically because it lets you write enclave logic in memory-safe, type-safe languages like Java or Kotlin. These languages eliminate by construction huge swathes of bugs. All buffer bounds are checked, no memory is freed before use and all casts are valid. This makes it much easier to process data from outside the enclave because you don't have to worry that you might accidentally let an attacker in. Sometimes people find this confusing: a JVM is quite large, so if the TCB needs to be small isn't that a problem? It's not for two reasons. One reason is because this heuristic only applies for code that an attacker can actually reach and influence via external input, but the input data to the JVM (bytecode) is itself a fixed part of the enclave. Attackers can't modify it without changing the measurement reported in the remote attestation and thus being detected by the client - the client's enclave constraint will be violated and an exception will be thrown. The second reason is that Conclave uses the GraalVM Native Image JVM, in which all bytecode is compiled to native code ahead of time. The actual JVM in use is therefore quite tiny; it consists mostly of the garbage collector. Warning Whilst garbage collected/type safe programs are much safer than programs written in C, they aren't immune to vulnerabilities. Watch out for very generic reflective code like object serialization frameworks, that could be tricked into deserializing malicious streams.","title":"Security"},{"location":"enclaves.html#auditability","text":"Enclaves are meaningless unless the user verifies the enclave does what they think it does before sending it private data. As the enclave size goes up it gets harder to read and understand its code. In practice audit work will often be outsourced: we don't expect that every end user of an enclave reads all the code themselves. Ultimately though, someone the user trusts must read all the code inside the enclave. The less there is to read the better. A lot of code works with data without parsing or understanding it. For instance, network frameworks read packets from the wire and databases store data to disk in generic ways. Other parts of a program truly understand the data and work with it in app-specific ways; usually this is called business logic. In enclave-oriented design you draw a bright line between host code and business logic. Business logic runs inside an enclave on normal Java objects. Host code does everything else: Network handling Storage Routing Monitoring Providing administration interfaces and so on. Keeping as much code in the host as possible has two key advantages: The host code is untrusted and assumed to be compromised. Thus any bugs in it are much less serious. You can worry less about security vulnerabilities in the host code because it can't access your user's private data. Because the enclave is small it will change less frequently, meaning clients don't need to re-audit or whitelist new versions. The second point is intuitive to understand. Think of your enclave as a concrete version of your privacy policy. If you change your web server, core database engine or even entire operating system then this is of no concern to your users. You've only changed how data is processed. But if you change what you do with their data, they may have an opinion on this and want to know about it. Remote attestation lets them see that the core business logic has changed, and in what way.","title":"Auditability"},{"location":"enclaves.html#enclaves-vs-alternative-approaches","text":"The enclave architecture is the result of many years of evolution. Enclaves are good at minimising TCB size because that was their entire design goal: an enclave is intended to be the smallest piece of application logic that needs to be protected. Some other systems work by attempting to protect and attest an entire operating system stack, but this was tried in the past and found to work poorly. Let us now briefly trace the historical evolution that led to the SGX enclave design today. The first attempts at implementing trusted computing relied on a so-called trusted platform module chip (TPM). The TPM contained special registers called platform configuration registers (PCR). A PCR was sized to contain a hash, but could not be written directly. Instead writing to a PCR concatenated the new hash value with the prior, and stored the result of hashing that concatenation. PCRs therefore contained the final hash in a chain of hashes. The only way to get a PCR to a particular value is to feed it the right sequence of hashes, called the chain of trust . The firmware and electronics on the motherboard implemented a static root of trust . In this design, the initial boot ROM would load the BIOS and other firmware, hash it into a PCR and then pass control to it. The firmware would then in turn hash and load the next stage into the same PCR and so on. Thus by the time the system booted, all the software and firmware on the system had been hashed together. The contents of the PCR could then be remotely attested and the user could verify what software booted. This then let them reason about how the remote computer would behave. Given the explanations above the problem with this approach is hopefully now obvious - this approach defined the TCB as everything in the entire boot sequence, including the whole operating system kernel. Any bug at any point in this code would allow someone to create a forged chain of trust and undermine the system. But system firmware is already very large and likely to contain bugs, let alone a kernel. And even if the entire boot was secure the operating system or application server would likely contain bugs allowing in remote attackers anyway. On the open PC platform this system turned out to be too easy to defeat, and became abandoned outside of a few use cases involving disk encryption (with no remote attestation). Despite its failure in PCs, static roots of trust worked well enough for games consoles where the entire boot sequence could be encrypted, locked down, attested to multi-player game networks and very carefully audited by a vertically integrated systems manufacturer. The next attempt introduced a dynamic chain of trust via Intel TXT and AMD SVM. TXT/SVM provided so-called \"late launch\" in which a hypervisor can be started up and measured whilst the system is running. The hypervisor can then measure and boot an operating system, which may be a small and special purpose operating system. This approach also failed to gain much traction, as at the time building a small special purpose OS was too difficult (whereas nowadays open source unikernel operating systems are more easily available), and booting a regular Linux faced many of the same problems as with the static root of trust: too many places to hide back doors, too many bugs for the system to be truly trustworthy. This is how we arrived at SGX. An enclave runs in user-space and does not require a large piece of code like a hypervisor, kernel and system firmware to become a part of the remote attestation. Instead, only a small statically linked binary is loaded and protected. The code in the enclave can communicate with the host process by reading and writing from host memory. The TCB size is finally minimised to only what is strictly necessary - as long as your app is designed correctly.","title":"Enclaves vs alternative approaches"},{"location":"faq.html","text":"Frequently asked questions \u00b6 What app architecture issues should we consider? \u00b6 We plan to offer more guidance on this in future. Until then consider: Dataset size. It must fit in memory in a single CPU machine. Lower performance than usual. The extra security checks used by SGX reduce execution performance and the embedded JVM inside the enclave isn't as sophisticated as HotSpot, so peak performance will be lower than normal for Java. Client-side tooling. Enclaves are useless unless the end user of the service they provide is checking a remote attestation. Because web browsers know nothing about remote attestation you will have to provide an independent tool that verifies this as part of interacting with the service (note: trying to implement this in JavaScript to run in a browser won't work given the enclave security model, as the JavaScript would come from the same host you're trying to audit). What cryptographic algorithm(s) does Conclave support? \u00b6 The elliptic curve used is Curve25519 for encryption and Ed25519 for signing. The symmetric cipher is AES256/GCM. The hash function is SHA256. The Noise protocol is used to perform Diffie-Hellman key agreement and set up the ciphering keys. As these algorithms represent the state of the art and are widely deployed on the web, there are no plans to support other algorithms or curves at this time. What Kotlin/Java versions are usable? \u00b6 Inside the enclave you can use Java 8 and Kotlin 1.3. Which communication channels exist to/from the enclave? \u00b6 The host can send and receive messages with the enclave, and an encryption key is included in the remote attestation. Clients may choose to use this key with Conclave Mail to communicate with the enclave in an encrypted manner. It's up to the host to route messages to and from the network. Why are you using Intel SGX versus mathematical techniques? \u00b6 Mathematically based secure multi-party computation and zero knowledge proofs are closely related and have similar tradeoffs/problems such as high complexity, low performance, difficult to use without intense dedicated training and not stable (i.e. the best known algorithms change frequently). SGX is relatively simple, high performance, much easier to use, and stable over time. However, we acknowledge the limits of relying on hardware based solutions and are interested in bringing easy to use circuit-based cryptographic algorithms to market one day. How are upgrades performed when patches are released? \u00b6 There are several components which might need an upgrade when a vulnerability is found. It might involve updates to the Intel platform services software (a daemon and some libraries on the host Linux machine), the BIOS or UEFI versions and configuration, Conclave, or even the application code itself. Some of these updates might involve rebooting the system, which can cause downtime depending on the security requirements of each application. Conclave Mail is designed to be an asynchronous messaging system, so restarts to upgrade to new versions would be seen by clients as a latency spike rather than downtime. It might be possible to perform a rolling update, permitting applications to continue working on a potentially compromised system while the rollout is being performed. Stateless enclaves are easier to interchange, since no state needs to be transferred to other enclave instances. In the case of stateful enclaves, the possibility for doing state transfers depend on the application requirements, since data sealed on a system cannot be unsealed on a different system. Who and what will we be trusting exactly? \u00b6 To ensure an enclave is behaving as expected one needs to verify its source and verify that the Intel attested reported measurement matches the expected measurement at runtime, which requires a reproducible build system. We provide this in Conclave. Regarding the who and what needs to be trusted, the above assumes trust in Intel and, when using Conclave, R3. Trust is needed on Intel\u2019s software, hardware and remote attestation services and R3\u2019s Conclave software stack implementation. However you don't need to trust the owner of the hardware on which you run. We plan in future to allow audits of the source code of Conclave, to allow users to establish trust in it directly. You must verify the source code of the enclave itself to ensure it\u2019s \"behaving properly\", e.g. it\u2019s not sending secrets to the host. Verifying the enclave measurement through Intel\u2019s remote attestation service is needed to ensure the source code matches the actual code running in the enclave. This also lets you check the remote system is fully up to date, and that the enclave is not running in debug mode (i.e. that the memory is really encrypted). How long should we trust an attestation verification report? \u00b6 When a flaw in the system is found Intel performs a \"trusted computing base recovery\" operation. This involves releasing security updates and adjusting their servers to start reporting that old versions are known to be compromised. Thus you shouldn't accept a remote attestation for too long. Intel provides official guidance with some recommendations: For organizations with low risk tolerance (for example, banking), the attestation frequency policy might be once per day or once per week. Organizations with higher risk tolerance may define a frequency policy of once every 180 days. A typical frequency policy is once every 30 days. At the moment the developer is responsible for writing code that restarts the enclave from time to time. Restarting the enclave will force a re-attestation and thus make the EnclaveInstanceInfo fresh again. How often this happens should be synchronised between the host and client side tool (but remember to make the host server refresh more frequently than the client requires, to avoid synchronisation errors). What about side-channel attacks? \u00b6 Please see the discussion of side channel attacks in the security documentation. At which points in time is a connection with Intel needed? \u00b6 A connection to Intel's servers will be made by the aesmd daemon and the host program when an enclave is loaded, as part of the startup sequence. See the information about machine setup to learn about firewall and proxy configuration. Will using Conclave require any agreements with Intel? \u00b6 To develop enclaves no agreements are required. To run enclaves in production you currently need: A \"service provider ID\" that grants access to the attestation servers. This is free. To sign a (very simple, one page) agreement that you won't sign malware. Intel will whitelist your signing key and Release Mode then becomes available. This is also free. So whilst enclave developers must interact with Intel to be able to use SGX it's not a difficult task, and step (2) is becoming optional in newer versions of SGX. Technically, the whitelisting authority becomes configurable via the BIOS/UEFI so you can set it to yourself, or for cloud/datacenter providers, enforce your own restrictions. This means that for example if you run a datacenter you can't find yourself unexpectedly serving un-analysable malware command and control servers, etc. Note that due to how Conclave is designed, enclave clients don't need to interact with Intel at any point. Instead the host does it for them, and then sends them a serialised EnclaveInstanceInfo object. Because the data in this object is signed by Intel the clients can check it despite it being relayed through the untrusted host. Do you have plans to support AMD SEV? \u00b6 Not at this time. We will re-evaluate future versions of SEV. The main problems are: AMD SEV is very strongly oriented around the protection of VMs in the cloud. Every protected domain has an owner that has full access to it. This makes it useless for multi-party computations where nobody should have access to the full state of the calculation. It has no equivalent of SGX TCB recovery, meaning flaws permanently break the system. Prior versions of SEV have been rendered useless by the discovery of numerous fatal bugs in AMD's firmware. Although patches were made available there's no way to remotely detect if they are actually applied. Additionally, in SEV remote attestation is randomized, which means you can\u2019t ask a remote host \"what are you running\". You are expected to know this already (because you set up the remote VM to begin with). This doesn't fit well with most obvious enclave APIs. Do you have plans to support ARM TrustZone? \u00b6 Not at this time. ARM TrustZone doesn't have any form of remote attestation support. It's meant for hardening mobile phone operating systems and supported use cases don't really go beyond that. Can I print debug output to the console from my enclave? \u00b6 Conclave enclaves built for debug and simulation support output to the console from inside the enclave through the use of System.out.println() . Release builds of enclaves do not support printing to the console. Calling System.out.println() in release builds of enclaves is allowed but the output is discarded inside the enclave. This is to prevent accidental leakage of enclave state through the use of debug logging.","title":"FAQ"},{"location":"faq.html#frequently-asked-questions","text":"","title":"Frequently asked questions"},{"location":"faq.html#what-app-architecture-issues-should-we-consider","text":"We plan to offer more guidance on this in future. Until then consider: Dataset size. It must fit in memory in a single CPU machine. Lower performance than usual. The extra security checks used by SGX reduce execution performance and the embedded JVM inside the enclave isn't as sophisticated as HotSpot, so peak performance will be lower than normal for Java. Client-side tooling. Enclaves are useless unless the end user of the service they provide is checking a remote attestation. Because web browsers know nothing about remote attestation you will have to provide an independent tool that verifies this as part of interacting with the service (note: trying to implement this in JavaScript to run in a browser won't work given the enclave security model, as the JavaScript would come from the same host you're trying to audit).","title":"What app architecture issues should we consider?"},{"location":"faq.html#what-cryptographic-algorithms-does-conclave-support","text":"The elliptic curve used is Curve25519 for encryption and Ed25519 for signing. The symmetric cipher is AES256/GCM. The hash function is SHA256. The Noise protocol is used to perform Diffie-Hellman key agreement and set up the ciphering keys. As these algorithms represent the state of the art and are widely deployed on the web, there are no plans to support other algorithms or curves at this time.","title":"What cryptographic algorithm(s) does Conclave support?"},{"location":"faq.html#what-kotlinjava-versions-are-usable","text":"Inside the enclave you can use Java 8 and Kotlin 1.3.","title":"What Kotlin/Java versions are usable?"},{"location":"faq.html#which-communication-channels-exist-tofrom-the-enclave","text":"The host can send and receive messages with the enclave, and an encryption key is included in the remote attestation. Clients may choose to use this key with Conclave Mail to communicate with the enclave in an encrypted manner. It's up to the host to route messages to and from the network.","title":"Which communication channels exist to/from the enclave?"},{"location":"faq.html#why-are-you-using-intel-sgx-versus-mathematical-techniques","text":"Mathematically based secure multi-party computation and zero knowledge proofs are closely related and have similar tradeoffs/problems such as high complexity, low performance, difficult to use without intense dedicated training and not stable (i.e. the best known algorithms change frequently). SGX is relatively simple, high performance, much easier to use, and stable over time. However, we acknowledge the limits of relying on hardware based solutions and are interested in bringing easy to use circuit-based cryptographic algorithms to market one day.","title":"Why are you using Intel SGX versus mathematical techniques?"},{"location":"faq.html#how-are-upgrades-performed-when-patches-are-released","text":"There are several components which might need an upgrade when a vulnerability is found. It might involve updates to the Intel platform services software (a daemon and some libraries on the host Linux machine), the BIOS or UEFI versions and configuration, Conclave, or even the application code itself. Some of these updates might involve rebooting the system, which can cause downtime depending on the security requirements of each application. Conclave Mail is designed to be an asynchronous messaging system, so restarts to upgrade to new versions would be seen by clients as a latency spike rather than downtime. It might be possible to perform a rolling update, permitting applications to continue working on a potentially compromised system while the rollout is being performed. Stateless enclaves are easier to interchange, since no state needs to be transferred to other enclave instances. In the case of stateful enclaves, the possibility for doing state transfers depend on the application requirements, since data sealed on a system cannot be unsealed on a different system.","title":"How are upgrades performed when patches are released?"},{"location":"faq.html#who-and-what-will-we-be-trusting-exactly","text":"To ensure an enclave is behaving as expected one needs to verify its source and verify that the Intel attested reported measurement matches the expected measurement at runtime, which requires a reproducible build system. We provide this in Conclave. Regarding the who and what needs to be trusted, the above assumes trust in Intel and, when using Conclave, R3. Trust is needed on Intel\u2019s software, hardware and remote attestation services and R3\u2019s Conclave software stack implementation. However you don't need to trust the owner of the hardware on which you run. We plan in future to allow audits of the source code of Conclave, to allow users to establish trust in it directly. You must verify the source code of the enclave itself to ensure it\u2019s \"behaving properly\", e.g. it\u2019s not sending secrets to the host. Verifying the enclave measurement through Intel\u2019s remote attestation service is needed to ensure the source code matches the actual code running in the enclave. This also lets you check the remote system is fully up to date, and that the enclave is not running in debug mode (i.e. that the memory is really encrypted).","title":"Who and what will we be trusting exactly?"},{"location":"faq.html#how-long-should-we-trust-an-attestation-verification-report","text":"When a flaw in the system is found Intel performs a \"trusted computing base recovery\" operation. This involves releasing security updates and adjusting their servers to start reporting that old versions are known to be compromised. Thus you shouldn't accept a remote attestation for too long. Intel provides official guidance with some recommendations: For organizations with low risk tolerance (for example, banking), the attestation frequency policy might be once per day or once per week. Organizations with higher risk tolerance may define a frequency policy of once every 180 days. A typical frequency policy is once every 30 days. At the moment the developer is responsible for writing code that restarts the enclave from time to time. Restarting the enclave will force a re-attestation and thus make the EnclaveInstanceInfo fresh again. How often this happens should be synchronised between the host and client side tool (but remember to make the host server refresh more frequently than the client requires, to avoid synchronisation errors).","title":"How long should we trust an attestation verification report?"},{"location":"faq.html#what-about-side-channel-attacks","text":"Please see the discussion of side channel attacks in the security documentation.","title":"What about side-channel attacks?"},{"location":"faq.html#at-which-points-in-time-is-a-connection-with-intel-needed","text":"A connection to Intel's servers will be made by the aesmd daemon and the host program when an enclave is loaded, as part of the startup sequence. See the information about machine setup to learn about firewall and proxy configuration.","title":"At which points in time is a connection with Intel needed?"},{"location":"faq.html#will-using-conclave-require-any-agreements-with-intel","text":"To develop enclaves no agreements are required. To run enclaves in production you currently need: A \"service provider ID\" that grants access to the attestation servers. This is free. To sign a (very simple, one page) agreement that you won't sign malware. Intel will whitelist your signing key and Release Mode then becomes available. This is also free. So whilst enclave developers must interact with Intel to be able to use SGX it's not a difficult task, and step (2) is becoming optional in newer versions of SGX. Technically, the whitelisting authority becomes configurable via the BIOS/UEFI so you can set it to yourself, or for cloud/datacenter providers, enforce your own restrictions. This means that for example if you run a datacenter you can't find yourself unexpectedly serving un-analysable malware command and control servers, etc. Note that due to how Conclave is designed, enclave clients don't need to interact with Intel at any point. Instead the host does it for them, and then sends them a serialised EnclaveInstanceInfo object. Because the data in this object is signed by Intel the clients can check it despite it being relayed through the untrusted host.","title":"Will using Conclave require any agreements with Intel?"},{"location":"faq.html#do-you-have-plans-to-support-amd-sev","text":"Not at this time. We will re-evaluate future versions of SEV. The main problems are: AMD SEV is very strongly oriented around the protection of VMs in the cloud. Every protected domain has an owner that has full access to it. This makes it useless for multi-party computations where nobody should have access to the full state of the calculation. It has no equivalent of SGX TCB recovery, meaning flaws permanently break the system. Prior versions of SEV have been rendered useless by the discovery of numerous fatal bugs in AMD's firmware. Although patches were made available there's no way to remotely detect if they are actually applied. Additionally, in SEV remote attestation is randomized, which means you can\u2019t ask a remote host \"what are you running\". You are expected to know this already (because you set up the remote VM to begin with). This doesn't fit well with most obvious enclave APIs.","title":"Do you have plans to support AMD SEV?"},{"location":"faq.html#do-you-have-plans-to-support-arm-trustzone","text":"Not at this time. ARM TrustZone doesn't have any form of remote attestation support. It's meant for hardening mobile phone operating systems and supported use cases don't really go beyond that.","title":"Do you have plans to support ARM TrustZone?"},{"location":"faq.html#can-i-print-debug-output-to-the-console-from-my-enclave","text":"Conclave enclaves built for debug and simulation support output to the console from inside the enclave through the use of System.out.println() . Release builds of enclaves do not support printing to the console. Calling System.out.println() in release builds of enclaves is allowed but the output is discarded inside the enclave. This is to prevent accidental leakage of enclave state through the use of debug logging.","title":"Can I print debug output to the console from my enclave?"},{"location":"ias.html","text":"Intel Attestation Service \u00b6 Important You need to read and perform these steps to deploy a Conclave app. How do you know a remote computer is fully up to date with the latest security patches and isn't physically compromised? This is the question Intel's Attestation Service (IAS) exists to answer. IAS is an online service that evaluates evidence from an enclave and returns: The time at which the assessment was made Whether the system is considered secure or whether it needs: Software upgrades Operating system / microcode upgrades BIOS configuration changes The CVE IDs of any active security advisories against the remote system ... along with various other pieces of data. The response is signed by Intel. Because it's signed it can be hosted and passed around by anyone, thus when an enclave is started in debug or production mode IAS is contacted and an attestation calculated. It's a part of a serialized EnclaveInstanceInfo object and can be passed to clients from the server. This means clients don't need to contact Intel's servers themselves and thus don't need authorisation to use IAS. Getting access \u00b6 IAS requires an authorised key to access it. This is distinct from the enclave signing key. To obtain an IAS access key: Sign the commercial use agreement as part of getting a whitelisted enclave signing key . Get an Intel developer zone account and sign in on the IAS API site . Subscribe to development and production access for \"EPID Name Base Mode (Linkable Quotes)\". You should give Intel a group email address rather than an individual address, as these will be used to send you notification of security advisories affecting your system, so you know to upgrade and the timelines for TCB recovery .","title":"IAS"},{"location":"ias.html#intel-attestation-service","text":"Important You need to read and perform these steps to deploy a Conclave app. How do you know a remote computer is fully up to date with the latest security patches and isn't physically compromised? This is the question Intel's Attestation Service (IAS) exists to answer. IAS is an online service that evaluates evidence from an enclave and returns: The time at which the assessment was made Whether the system is considered secure or whether it needs: Software upgrades Operating system / microcode upgrades BIOS configuration changes The CVE IDs of any active security advisories against the remote system ... along with various other pieces of data. The response is signed by Intel. Because it's signed it can be hosted and passed around by anyone, thus when an enclave is started in debug or production mode IAS is contacted and an attestation calculated. It's a part of a serialized EnclaveInstanceInfo object and can be passed to clients from the server. This means clients don't need to contact Intel's servers themselves and thus don't need authorisation to use IAS.","title":"Intel Attestation Service"},{"location":"ias.html#getting-access","text":"IAS requires an authorised key to access it. This is distinct from the enclave signing key. To obtain an IAS access key: Sign the commercial use agreement as part of getting a whitelisted enclave signing key . Get an Intel developer zone account and sign in on the IAS API site . Subscribe to development and production access for \"EPID Name Base Mode (Linkable Quotes)\". You should give Intel a group email address rather than an individual address, as these will be used to send you notification of security advisories affecting your system, so you know to upgrade and the timelines for TCB recovery .","title":"Getting access"},{"location":"known-issues.html","text":"Known issues \u00b6 During the beta period the API may change up in backwards incompatible ways. Although we have no current plans to change the API, small changes like package names may still occur and we may adapt the API based on user feedback during the beta period. This release ships with the following known issues that we plan to address in future versions: The Mail API will change in future beta releases. Conclave doesn't presently implement any automatic side channel attack mitigations. Some system level exceptions like divide by zero or using null reference may crash the enclave/host process. The type of attestation used currently requires you to sign up with and be whitelisted by Intel. Future versions will implement \"DCAP attestation\" which will allow the owner of the hardware to whitelist enclaves, not just Intel. TCB recoveries invalidate remote attestations, such that enclaves cannot read mail sent to them from before the upgrade. The enclave hangs if it's asked to terminate whilst threads are still active inside it. Some Java APIs won't currently work due to lack of full operating system access inside the enclave. We plan to fix these issues in upcoming betas, to present the enclave with e.g. an empty file system. Mail is limited in size by the size of the enclave heap, and the size of a Java array (2 gigabytes). Windows enclave builds don't identically reproduce Linux and macOS builds.","title":"Known issues"},{"location":"known-issues.html#known-issues","text":"During the beta period the API may change up in backwards incompatible ways. Although we have no current plans to change the API, small changes like package names may still occur and we may adapt the API based on user feedback during the beta period. This release ships with the following known issues that we plan to address in future versions: The Mail API will change in future beta releases. Conclave doesn't presently implement any automatic side channel attack mitigations. Some system level exceptions like divide by zero or using null reference may crash the enclave/host process. The type of attestation used currently requires you to sign up with and be whitelisted by Intel. Future versions will implement \"DCAP attestation\" which will allow the owner of the hardware to whitelist enclaves, not just Intel. TCB recoveries invalidate remote attestations, such that enclaves cannot read mail sent to them from before the upgrade. The enclave hangs if it's asked to terminate whilst threads are still active inside it. Some Java APIs won't currently work due to lack of full operating system access inside the enclave. We plan to fix these issues in upcoming betas, to present the enclave with e.g. an empty file system. Mail is limited in size by the size of the enclave heap, and the size of a Java array (2 gigabytes). Windows enclave builds don't identically reproduce Linux and macOS builds.","title":"Known issues"},{"location":"machine-setup.html","text":"Before you can deploy an enclave to use real SGX hardware you need to configure the host system, and get access to the Intel Attestation Service . At this time the host must be Linux and requires the following steps: Installing the SGX kernel driver, which isn't yet included in upstream kernels. Installing the Intel platform services software. Follow the instructions at the IAS website to get access to the IAS servers using a whitelisted SSL key. Note To just develop enclaves it's sufficient to have any Linux or Windows host, as the simulation mode requires no special machine setup. Hardware support \u00b6 The machine needs support from both the CPU and firmware. At this time multi-socket boards don't support SGX. Your hardware manufacturer can tell you if your machine supports SGX, but most new computers do (one exception is anything made by Apple). There is a community maintained list of tested/compatible hardware available on GitHub . For some machines SGX must be explicitly enabled in the BIOS/UEFI firmware screens. For others it can be activated by any root user: the Conclave host API will try to activate it for you, if possible and if run with sufficient permissions. Hosting providers \u00b6 In the cloud Microsoft Azure offers virtual machines with SGX hardware , and rented colo hardware is often available with it too. OVH offers rentable SGX hardware , as an example of one provider. Distribution support \u00b6 The following Linux distros are formally supported by Intel: Ubuntu 16.04.3 LTS Desktop 64bits Ubuntu 16.04.3 LTS Server 64bits Ubuntu 18.04 LTS Desktop 64bits Ubuntu 18.04 LTS Server 64bits Red Hat Enterprise Linux Server release 7.4 64bits Red Hat Enterprise Linux Server release 8.0 64bits CentOS 7.4.1708 64bits SUSE Linux Enterprise Server 12 64bits However, others will probably still work. Install the kernel driver and system software \u00b6 Installers for the system software can be obtained from Intel . We recommend reading the installation user guide . The installation process is simple. Intel provide: APT repositories for Ubuntu Cross-distro installer binaries for other platforms, which set up the system software and compile/install the kernel driver. Important The installer will need to be re-run when the kernel is upgraded. Alternatively, you can compile the system software yourself. The kernel driver is also available on GitHub . For SGX remote attestation to operate and machine provisioning to succeed, a small daemon called aesmd is used. This comes as part of the SGX platform services software and will be set up during the install process. The quick summary looks like this: Download and run the driver installer binary (all distros) For Ubuntu users, as root run: For Ubuntu 16 LTS: echo 'deb [arch=amd64] https://download.01.org/intel-sgx/sgx_repo/ubuntu xenial main' > /etc/apt/sources.list.d/intelsgx.list For Ubuntu 18 LTS: echo 'deb [arch=amd64] https://download.01.org/intel-sgx/sgx_repo/ubuntu bionic main' > /etc/apt/sources.list.d/intelsgx.list Add the Intel package signing key: wget -qO - https://download.01.org/intel-sgx/sgx_repo/ubuntu/intel-sgx-deb.key | apt-key add - Then run apt-get update And finally apt-get install libssl-dev libcurl4-openssl-dev libprotobuf-dev libsgx-urts libsgx-launch libsgx-epid libsgx-quote-ex For other users, use the SDK installer (which installs the platform services software as well) These steps will start the aesm_service . Limited network connectivity \u00b6 The enclave host machine needs to contact Intel's attestation servers, as part of proving to third parties that it's a genuine unrevoked CPU running in the latest known secure configuration. Therefore if the machine has limited connectivity you must use an outbound HTTP[S] proxy server. The aesmd service has a configuration file in /etc/aesmd.conf . You may need to put your proxy settings there. The program that uses Conclave will also need to make web requests to https://api.trustedservices.intel.com so you may need to provide Java with HTTP proxy settings as well. Using containers \u00b6 To configure Docker for use with SGX, you must pass at least these flags when creating the container: --device=/dev/isgx -v /var/run/aesmd/aesm.socket:/var/run/aesmd/aesm.socket Failure to do this may result in an SGX_ERROR_NO_DEVICE error when creating an enclave. Renewing machine security \u00b6 After following the above instructions, you may discover your EnclaveInstanceInfo objects report the enclave as STALE . This means the machine requires software updates. Applying all available updates and rebooting should make the security evaluation of STALE go away. See \"Renewability\" to learn more about this topic and what exactly is involved.","title":"Machine setup"},{"location":"machine-setup.html#hardware-support","text":"The machine needs support from both the CPU and firmware. At this time multi-socket boards don't support SGX. Your hardware manufacturer can tell you if your machine supports SGX, but most new computers do (one exception is anything made by Apple). There is a community maintained list of tested/compatible hardware available on GitHub . For some machines SGX must be explicitly enabled in the BIOS/UEFI firmware screens. For others it can be activated by any root user: the Conclave host API will try to activate it for you, if possible and if run with sufficient permissions.","title":"Hardware support"},{"location":"machine-setup.html#hosting-providers","text":"In the cloud Microsoft Azure offers virtual machines with SGX hardware , and rented colo hardware is often available with it too. OVH offers rentable SGX hardware , as an example of one provider.","title":"Hosting providers"},{"location":"machine-setup.html#distribution-support","text":"The following Linux distros are formally supported by Intel: Ubuntu 16.04.3 LTS Desktop 64bits Ubuntu 16.04.3 LTS Server 64bits Ubuntu 18.04 LTS Desktop 64bits Ubuntu 18.04 LTS Server 64bits Red Hat Enterprise Linux Server release 7.4 64bits Red Hat Enterprise Linux Server release 8.0 64bits CentOS 7.4.1708 64bits SUSE Linux Enterprise Server 12 64bits However, others will probably still work.","title":"Distribution support"},{"location":"machine-setup.html#install-the-kernel-driver-and-system-software","text":"Installers for the system software can be obtained from Intel . We recommend reading the installation user guide . The installation process is simple. Intel provide: APT repositories for Ubuntu Cross-distro installer binaries for other platforms, which set up the system software and compile/install the kernel driver. Important The installer will need to be re-run when the kernel is upgraded. Alternatively, you can compile the system software yourself. The kernel driver is also available on GitHub . For SGX remote attestation to operate and machine provisioning to succeed, a small daemon called aesmd is used. This comes as part of the SGX platform services software and will be set up during the install process. The quick summary looks like this: Download and run the driver installer binary (all distros) For Ubuntu users, as root run: For Ubuntu 16 LTS: echo 'deb [arch=amd64] https://download.01.org/intel-sgx/sgx_repo/ubuntu xenial main' > /etc/apt/sources.list.d/intelsgx.list For Ubuntu 18 LTS: echo 'deb [arch=amd64] https://download.01.org/intel-sgx/sgx_repo/ubuntu bionic main' > /etc/apt/sources.list.d/intelsgx.list Add the Intel package signing key: wget -qO - https://download.01.org/intel-sgx/sgx_repo/ubuntu/intel-sgx-deb.key | apt-key add - Then run apt-get update And finally apt-get install libssl-dev libcurl4-openssl-dev libprotobuf-dev libsgx-urts libsgx-launch libsgx-epid libsgx-quote-ex For other users, use the SDK installer (which installs the platform services software as well) These steps will start the aesm_service .","title":"Install the kernel driver and system software"},{"location":"machine-setup.html#limited-network-connectivity","text":"The enclave host machine needs to contact Intel's attestation servers, as part of proving to third parties that it's a genuine unrevoked CPU running in the latest known secure configuration. Therefore if the machine has limited connectivity you must use an outbound HTTP[S] proxy server. The aesmd service has a configuration file in /etc/aesmd.conf . You may need to put your proxy settings there. The program that uses Conclave will also need to make web requests to https://api.trustedservices.intel.com so you may need to provide Java with HTTP proxy settings as well.","title":"Limited network connectivity"},{"location":"machine-setup.html#using-containers","text":"To configure Docker for use with SGX, you must pass at least these flags when creating the container: --device=/dev/isgx -v /var/run/aesmd/aesm.socket:/var/run/aesmd/aesm.socket Failure to do this may result in an SGX_ERROR_NO_DEVICE error when creating an enclave.","title":"Using containers"},{"location":"machine-setup.html#renewing-machine-security","text":"After following the above instructions, you may discover your EnclaveInstanceInfo objects report the enclave as STALE . This means the machine requires software updates. Applying all available updates and rebooting should make the security evaluation of STALE go away. See \"Renewability\" to learn more about this topic and what exactly is involved.","title":"Renewing machine security"},{"location":"mail.html","text":"Mail \u00b6 A mail is an authenticated message with an encrypted body and a cleartext envelope. The mail can be up to two gigabytes in size, however, it must at this time fit into memory when loaded all at once. In practice mails will usually be much smaller than that. Mail provides a variety of features that are useful when building applications: Encryption. The encryption key used by the enclave is private to that enclave but stable across restarts and enclave upgrades. This means messages encrypted and delivered by older clients can still be decrypted. The format uses the respected Noise protocol framework (with AES/GCM and SHA-256), which is the same cryptographic framework used by WhatsApp, the Linux kernel WireGuard protocol and I2P. Authentication. Mail allows a message to prove it came from the owner of a particular key, as well as being encrypted to a destination public key. Because of this it's easy to encrypt a reply to the sender, although how a public key is mapped to a physical computer is up to the app developer. This capability is useful for another reason: if an enclave has a notion of a user identifiable by public key, mail can be cryptographically authenticated as having come from that user. This avoids the need for complex user login processes: the login process can be handled outside of the enclave, without compromising security. The envelope is protected this way along with the encrypted body. Headers. Mail has unencrypted but authenticated (tamperproof) headers that can be used to link messages together. This allows clients to structure a conversation as if they were using a socket, but also hold multiple conversations simultaneously. This can be used to implement usage tracking, prioritisation, or other tasks not directly relevant to data processing that the host can assist with (despite its untrusted nature). Headers provide strong sequence numbers that are set by the sender and prevent the host re-ordering messages, a \"topic\" string field that is more useful than a port number (e.g. can identify what it's about, be mapped to message queue names), and applications can put their own data in the envelope part of the headers thus enabling hosts to see part of the messages. This can frequently be a useful design pattern. Framing. A typical need with any socket or stream based transport is to add framing on top, because the application really needs to work with messages. In textual protocols framing can be remarkably tricky to get right, as user or attacker controlled data may be placed inside a message, meaning any characters that mark the end of a message need to be escaped. This can go wrong in a variety of interesting ways . Mail by its nature delimits messages such that you can always tell where they begin and end, without needing to impose your own framing on top. Future features \u00b6 We plan to add additional features to the mail API in upcoming releases: Padding. The body of a mail will be automatically padded to reduce or eliminate size-based side channel attacks. The size of a message won't give away information about the contents. See side channel attacks . Storage. Mail will be stored by the host process. Often an enclave is implementing a form of batch job. By allowing the host to handle storage of messages, mail allows it to delay starting the enclave until enough data has arrived. This in turn allows the host to best utilise the limited pool of encrypted RAM available for enclaves. Atomicity. Mail should be delivered by the host to an enclave on each startup, until the mail is acknowledged. Acknowledgement and posting mail will become transactional, thus can be performed atomically with other acknowledgements and sending other replies. In this way enclaves can ensure that restarting an enclave doesn't produce duplicate messages, perform the same actions twice or cause service interruptions to users. Notice More sophisticated database solutions may be added in future releases. Using mail for storage \u00b6 Mail is not only intended for messaging. It subsumes the \"sealing\" functionality that appears in most trusted computing platforms. By sending mail to itself an enclave can store chunks of data that will be fed back to it at startup. It can then delete these chunks by acknowledging the mails. Utilising mail this way has a variety of advantages: The same encryption, authentication and TCB management features are available for stored data as well as messaging. The API is simple and used the same way for both use cases. Mail acknowledgement can be used to control data lifetime, by having enclaves signal to the host that it's safe to delete data which is no longer needed. Stored data typically comes from input data (i.e. messages) and may be stored incrementally. Sequence numbers and topics provide a way to organise stored data that can be integrated with the client's view of time, thus allowing rollback attacks on storage to be detected and blocked in some cases. This isn't a replacement for a full database. However, in many cases it may be more appropriate, as accessing a database from an enclave can leak a lot of data via access patterns and of course the database itself may need access to the unencrypted data to index or search it. The mail-to-self pattern avoids this by storing the dataset in memory and always reading all stored data at startup. Note In beta 3 storage management is delegated to the application. The enclave may signal acknowledgement requests to the host but by default nothing is done with them. Attacks on messaging \u00b6 Mail is designed to block a variety of attacks the host can mount on the enclave. Observation. The body of the mail is encrypted with industry standard AES/GCM. The host can't see what the client is sending to the client. Tampering. All the encrypted body, the plaintext headers and the user-specifiable envelope header are authenticated such that the enclave can detect if they were tampered with. See below for more information on this. Reordering. The enclave can't directly access any hardware other than the CPU and RAM. That means it can't know that messages came from the network card or hard disk in the right order, or that no messages were dropped. Mails include a sequence number in the headers, meaning it is visible to the host but can't be tampered with. This enlists the client as an ally in the enclave's war against the host: the client wants its messages to be delivered in the right order and without being dropped. The Conclave runtime checks the sequence numbers in the headers always increment before passing the mail to your code. Note The host may arbitrarily delay or even refuse to deliver mail, but it can only end the stream of mails early, it can't re-order messages relative to each other. This is a feature not a bug, as if the enclave could force the host to deliver mail that would imply it had actually taken over the computer somehow and was forcing it to provide services to the enclave. SGX isn't a form of remote control and nobody can force a host to run enclaves against its will. Side channel inspection. Future versions of mail will provide automatic and manual ways to pad messages, so their size can't give away any clues as to their contents. This is in fact one of the benefits of mail: if Conclave couldn't understand the message structure of your app (e.g. because it provided only a stream interface) then it wouldn't be able to do this type of padding. How does Mail work \u00b6 When viewed as a structured array of bytes, a mail consists of five parts: The protocol ID. The unencrypted headers, which have fields simply laid out in order. The unencrypted envelope, which is empty by default and exists for you to add whatever data you like (i.e. additional headers). The handshake. The encrypted body. Let's call the protocol ID, unencrypted headers and envelope the prologue . At the core of Mail's security is the handshake. It consists of the data needed to do an elliptic curve Diffie-Hellman calculation and derive a unique (per mail) AES/GCM key, using the Noise protocol specification . AES/GCM is an authenticated encryption mechanism. That means the key is used not only to encrypt data, but also calculate a special hash called a \"tag\" that allows detection of modifications to the encrypted data. This matters because 'raw' encryption merely stops someone reading a message: if they already know what some parts of the message say (e.g. because it's a well known data structure) then by flipping bits in the encrypted data, corruption can be created in the decrypted message. In some situations these corruptions could change the way the message is parsed leading to an exploit, for example, by changing a zero to a one and gaining administrator access . Like all symmetric ciphers, for AES/GCM to work both sides must know the same key. But we want to be able to send messages to a target for which we only know a public key, and have never had a chance to securely generate a joint AES key with. This is the problem solved by the Elliptic Curve Diffie-Hellman algorithm . To use it we first select a large random number (256 bits) and then convert that to a coordinate on an elliptic curve - in our case, we use Curve25519, which is a modern and highly robust elliptic curve. The point is our public key and can be encoded in another 256 bits (32 bytes). We write this public key after the unencrypted envelope. This key is an ephemeral key - we picked it just for the purposes of creating this mail. We know the target's public key either because the enclave puts it public key into the remote attestation, represented by an EnclaveInstanceInfo object, or because the enclave is replying and obtained the key to reply to from an earlier mail. Two public keys is all that's needed for both parties to compute the same AES key, without any man-in-the-middle being able to calculate the same value. The sender may also have a long term \"static\" public key that the target will recognise. However, at this point we may choose to finish the handshake, either because we are sending a mail anonymously or because the target will recognise us in some other manner than our static key. Alternatively, we may now append an encryption of our long term static public key and repeat the calculation between the enclave's public key and our static key, generating a new AES/GCM key as a result. As each step in the handshake progresses, a running hash is maintained that mixes in the hash of the prologue and the various intermediate stages. This allows the unencrypted headers to be tamper-proofed against the host as well, because the host will not be able to recalculate the authentication tag emitted to the end of the handshake. Thus, in the case where the sender has a long term keypair, the handshake consists of a random public key, an authenticated encryption of the sender's public key, and an authentication hash. Once this is done the mail's AES key has been computed. The initialization vector for each AES encryption is a counter (an exception will be thrown if the mail is so large the counter would wrap around, as that would potentially reveal information for cryptanalysis, however this cannot happen given the maximum mail size). The encrypted body consists of a set of 64kb packets. Each packet has its own authentication tag, thus data is read from a mail in 64kb chunks. Packets may also contain a true length as distinct from the length of the plaintext. This allows the sender to artificially inflate the size of the encrypted message by simply padding it with zeros, which enables hiding of the true message size. Message sizes can be a giveaway to what exact content it contains. Comparison to a classical architecture using REST and SSL \u00b6 Let's look at why Conclave provides Mail, instead of having clients connect into an enclave using HTTPS. Note The following explanation applies when connecting to the enclave . When connecting to the host you may use whatever transport mechanism you like to pass mail around. Conclave doesn't currently privilege any particular transport over any other. We provide the mail paradigm for these reasons: HTTPS requires a relatively large and complex infrastructure, increasing the size of the trusted computing base (TCB). It can go wrong in ways that aren't intuitive. Mail attempts to solve some common security problems before they start. SSL/TLS is not well adapted to enclaves, for example certificates don't make sense, but the protocol requires them. Web servers require the backing of a database to ensure session persistence and atomicity, but this interacts badly with the way enclaves handle time and state. Mail allows for a very simple approach to restarting and upgrading enclaves. The primary reason to use HTTPS+REST is familiarity and installed base of tools. However, none of these tools or libraries understand SGX remote attestation so cannot be used in their regular modes and must be modified or adjusted in complex ways, thus invalidating most of the benefits. We'll now explore these issues in more depth. TCB size \u00b6 The code that handles encrypted messaging is directly exposed to attackers. It is important to minimise the amount of code exposed in this way. For more discussion of how enclaves are designed to minimise code size, please see \"Small is beautiful\" . TLS complexity \u00b6 Mail is based on the Noise protocol framework . Noise is designed by professional cryptographers and is used in WhatsApp, WireGuard and other modern network protocols. Noise was created because TLS is weighed down with complicated historical baggage and web-specific features. A Noise protocol delivers most of the same functionality but in a more modular, cleaner and simpler way. Therefore, outside of the web the primary reason to use TLS is compatibility, not technical excellence. Now there is Noise there isn't much reason to use TLS anymore when designing a new protocol from scratch, unless you really need its features or support. TLS 1.3 recognises this problem and simplifies the protocol, but it's still far more complex than a Noise protocol, and because the purpose of using TLS is compatibility and TLS 1.3 is very new, realistically you will support TLS 1.2 as well. So now you have even more complexity in your enclave because you need both 1.2 and 1.3 support simultaneously. A big source of complexity in TLS is X.509 certificates. Certificates do not make sense for an enclave but TLS absolutely requires them, so some systems try to jam fake pseudo-certificates into TLS, which aren't real but contain the remote attestation in an extension field. Fake certificates can create problems because a lot of organisations have decades of procedures and best practices around all aspects of certificates and X.509, so fake pseudo-certificates can end up harder to deploy and work with than a purely technical analysis would suggest. Noise is more modular - you can provide any arbitrary byte array as part of the handshake, which can thus include a certificate (of any format) if you want that, but it isn't necessary. In Conclave the \"certificate\" is the remote attestation data represented as an EnclaveInstanceInfo object. It will usually make sense to expose this to the client via some app-specific mechanism, for example, returning it in some other API, publishing it on a web server, a network drive, a message queue, even putting it into a distributed hash table. Noise and by extension Conclave doesn't care how you get this data, only that you have it. Certificates don't make sense for enclaves because TLS is all about verifiable names as a form of identity, but enclaves are all about measurements and remote attestations . Thus, any client tool that communicates with an enclave will need to extract a remote attestation from a pseudo-certificate and throw out the rest. Given that you would need complex custom client-side code anyway, TLS buys you little beyond brand recognition. Notice This logic applies when connecting to an enclave . When connecting to a host the domain name identity of the server owner may well matter, and in that case TLS can be useful. TLS stacks have a history of being extremely buggy. The security TLS supposedly adds has a track record of being undermined by bugs in the implementations e.g. Heartbleed. Putting a TLS stack into an enclave makes it much bigger and harder to audit. In Conclave, we could use the JSSE Java SSL implementation and thus avoid memory management errors, but there are other kinds of issues that can be experienced with TLS too, that Java cannot protect us from. We use a pure Java implementation of Noise which ensures there are no buffer overflows in our crypto stack, and it's small enough that we have read every line. By licensing Conclave you can get the code, and then you can read every line too. This is impractical for a TLS stack. Finally, TLS mandates complex session persistence. This is a subtle point that deserves deeper discussion. Sessions and forward secrecy \u00b6 One of the upgrades Noise gives us is the ability to encrypt in both interactive and one-way modes e.g. for encrypting a file. TLS and HTTPS are fundamentally interactive protocols and cannot do this. TLS is interactive because the modern way to use it (and the only way in TLS 1.3) is with forward secrecy . In a scheme with forward secrecy two sides calculate an ephemeral session symmetric key during the handshake, that is used only for a short period and then deleted - usually this means the ephemeral key is stored only in RAM. In theory this is good, because it means if someone hacks the server/enclave they can't decrypt all the old messages they might have recorded. The private key is used only to establish identity, not actually encrypt any messages. With a purely one-way handshake you don't get this. Forward secrecy is a rather slippery feature. The problem is simple - what does \"short period\" mean? This is surprisingly hard to answer. TLS was designed for the web so at first this meant a TCP connection that carried a few web requests. So, usually a few seconds or perhaps hours if doing a big download. These days it gets used in many other kinds of apps and thus might mean much longer sessions, but fundamentally a TLS session was tied to the lifetime of a socket and therefore it couldn't last very long. Handshaking to set up a new session key is slow, so various optimisations were introduced. Connections were kept alive longer, and TLS added \"session resume\" that allowed session keys to be saved to disk and continued in later connections. For this to actually add any security it has to be harder to steal the cached session keys than the identity keys, but why would this be so when they're both stored in ordinary files ? But there's actually an even deeper conceptual problem. TLS encrypts sockets. It has nothing to say about the wider design of your app - that's out of scope for the people designing TLS. As a consequence TLS sessions don't bear any resemblance to actual user sessions. The intuition behind forward secrecy is a sort of controlled forgetting ... when the session ends the keys that could decrypt it are destroyed, so even if a passive observer stops being passive and hacks someone's private key they can't get the \"forgotten\" data. If web apps forgot everything you uploaded for no better reason than you changed from 4G to Wi-Fi people would get pretty upset. So HTTP has the idea of cookies, but even that is too transient for most users, which is why web apps normally require you to log in to an account. The actual data an attacker cares about is tied to the lifetime of an account, not a TCP connection. To make this work servers must store user session data into a database. This is so obvious and natural we hardly think about it, but it largely obliterates the supposed benefits of forward secrecy - the private key is held on the server, so if you can steal it you can probably steal the database credentials that are also stored on the server. And then you can just steal the valuable user data out of the database, you don't need to decrypt TLS sessions anymore. The biggest risk to an enclave is that the host can read its memory and thus steal its keys. Forward secrecy doesn't help you with this because users (we think) won't tolerate an app that forgets stuff if a TCP connection resets, and operations teams won't tolerate software that can't be safely restarted. So in practice an enclave will immediately re-encrypt data received from a client under a static sealing key, and if you can steal a TLS private key out of an enclave you can also steal a sealing key. So it buys you nothing. Moreover, it's insufficient to simply seal a byte array. You will probably need some sort of minimal database infrastructure, to keep data separated by user and so on. So now you have the complexity of a data management layer in the enclave as well. The result of all this is we don't lose much by using a more asynchronous design in which there isn't an interactive handshake. Benefits of Noise \u00b6 By losing TLS we can: Eliminate huge complexity from in-enclave code. Avoid pseudo-certificates and other hacks that will open up exploits and hit corporate X.509 bureaucracy. Enable enclaves to talk to each other even if they can't be loaded simultaneously (e.g. on same machine) Move session management and expiry out of the enclave, where it can't be done properly anyway because there's no secure access to the clock. Get various other benefits, like being able to reuse MQ brokers, integrate with Corda flows, store messages to databases, support M-to-1 inbound message collection before processing and so on. Messages vs streams \u00b6 There are three main ways for networked programs to communicate: streams, messages and RPCs. The popular REST paradigm is a form of RPC for the purposes of this discussion. Multi-party computations all involve the transmission of relatively small messages, often without needing any immediate reply. For instance, over the course of a day parties may submit a small data structure when a human gets around to it, and get the results back hours later when a deadline or threshold is reached. In other cases submission of data to an enclave may be asynchronous and should not block a business process in case of outage. These requirements are not a good fit for stream-oriented connections that when on top of TCP require app developers to do their own framing (a frequent source of security vulnerabilities), can break due to NAT boxes timing them out, IP address changes, passing through one-way firewalls, require high-availability servers with load balancing, require databases for stored state and so on. With a stream or RPC oriented approach the enclave would be expected to respond to bytes from a client more or less immediately, meaning it has to be always running and would have to persist uploaded data itself. Unfortunately persistence in enclaves is tricky due to the existence of Memento attacks (see \" Handling time and state \"). RPCs (including REST) can be hard to integrate with fully reliable systems that can tolerate restarts at any moment. Because server restarts break connections, in a loosely coupled multi-party system connection-oriented protocols require expensive HA load balancing to ensure users aren't often exposed to errors caused by planned restarts. Even then it isn't possible to eliminate such errors entirely, just reduce their impact. Load balancing in an enclave environment requires special support because the client is intimately aware of the exact CPU the enclave is running on - thus switching a client between servers isn't transparent. Note Future versions of Conclave are planned to add support for enclave clustering. All this suggests the primary paradigm exposed to enclaves should be messages. The host will take care of delivering messages and providing atomic, transactional semantics over them so many kinds of enclaves won't need an encrypted database at all. The untrusted host can also take on the significant burden of moving data around, storing it to disk, sorting it, applying backpressure, exposing to the admin if there are backlogs etc.","title":"Mail"},{"location":"mail.html#mail","text":"A mail is an authenticated message with an encrypted body and a cleartext envelope. The mail can be up to two gigabytes in size, however, it must at this time fit into memory when loaded all at once. In practice mails will usually be much smaller than that. Mail provides a variety of features that are useful when building applications: Encryption. The encryption key used by the enclave is private to that enclave but stable across restarts and enclave upgrades. This means messages encrypted and delivered by older clients can still be decrypted. The format uses the respected Noise protocol framework (with AES/GCM and SHA-256), which is the same cryptographic framework used by WhatsApp, the Linux kernel WireGuard protocol and I2P. Authentication. Mail allows a message to prove it came from the owner of a particular key, as well as being encrypted to a destination public key. Because of this it's easy to encrypt a reply to the sender, although how a public key is mapped to a physical computer is up to the app developer. This capability is useful for another reason: if an enclave has a notion of a user identifiable by public key, mail can be cryptographically authenticated as having come from that user. This avoids the need for complex user login processes: the login process can be handled outside of the enclave, without compromising security. The envelope is protected this way along with the encrypted body. Headers. Mail has unencrypted but authenticated (tamperproof) headers that can be used to link messages together. This allows clients to structure a conversation as if they were using a socket, but also hold multiple conversations simultaneously. This can be used to implement usage tracking, prioritisation, or other tasks not directly relevant to data processing that the host can assist with (despite its untrusted nature). Headers provide strong sequence numbers that are set by the sender and prevent the host re-ordering messages, a \"topic\" string field that is more useful than a port number (e.g. can identify what it's about, be mapped to message queue names), and applications can put their own data in the envelope part of the headers thus enabling hosts to see part of the messages. This can frequently be a useful design pattern. Framing. A typical need with any socket or stream based transport is to add framing on top, because the application really needs to work with messages. In textual protocols framing can be remarkably tricky to get right, as user or attacker controlled data may be placed inside a message, meaning any characters that mark the end of a message need to be escaped. This can go wrong in a variety of interesting ways . Mail by its nature delimits messages such that you can always tell where they begin and end, without needing to impose your own framing on top.","title":"Mail"},{"location":"mail.html#future-features","text":"We plan to add additional features to the mail API in upcoming releases: Padding. The body of a mail will be automatically padded to reduce or eliminate size-based side channel attacks. The size of a message won't give away information about the contents. See side channel attacks . Storage. Mail will be stored by the host process. Often an enclave is implementing a form of batch job. By allowing the host to handle storage of messages, mail allows it to delay starting the enclave until enough data has arrived. This in turn allows the host to best utilise the limited pool of encrypted RAM available for enclaves. Atomicity. Mail should be delivered by the host to an enclave on each startup, until the mail is acknowledged. Acknowledgement and posting mail will become transactional, thus can be performed atomically with other acknowledgements and sending other replies. In this way enclaves can ensure that restarting an enclave doesn't produce duplicate messages, perform the same actions twice or cause service interruptions to users. Notice More sophisticated database solutions may be added in future releases.","title":"Future features"},{"location":"mail.html#using-mail-for-storage","text":"Mail is not only intended for messaging. It subsumes the \"sealing\" functionality that appears in most trusted computing platforms. By sending mail to itself an enclave can store chunks of data that will be fed back to it at startup. It can then delete these chunks by acknowledging the mails. Utilising mail this way has a variety of advantages: The same encryption, authentication and TCB management features are available for stored data as well as messaging. The API is simple and used the same way for both use cases. Mail acknowledgement can be used to control data lifetime, by having enclaves signal to the host that it's safe to delete data which is no longer needed. Stored data typically comes from input data (i.e. messages) and may be stored incrementally. Sequence numbers and topics provide a way to organise stored data that can be integrated with the client's view of time, thus allowing rollback attacks on storage to be detected and blocked in some cases. This isn't a replacement for a full database. However, in many cases it may be more appropriate, as accessing a database from an enclave can leak a lot of data via access patterns and of course the database itself may need access to the unencrypted data to index or search it. The mail-to-self pattern avoids this by storing the dataset in memory and always reading all stored data at startup. Note In beta 3 storage management is delegated to the application. The enclave may signal acknowledgement requests to the host but by default nothing is done with them.","title":"Using mail for storage"},{"location":"mail.html#attacks-on-messaging","text":"Mail is designed to block a variety of attacks the host can mount on the enclave. Observation. The body of the mail is encrypted with industry standard AES/GCM. The host can't see what the client is sending to the client. Tampering. All the encrypted body, the plaintext headers and the user-specifiable envelope header are authenticated such that the enclave can detect if they were tampered with. See below for more information on this. Reordering. The enclave can't directly access any hardware other than the CPU and RAM. That means it can't know that messages came from the network card or hard disk in the right order, or that no messages were dropped. Mails include a sequence number in the headers, meaning it is visible to the host but can't be tampered with. This enlists the client as an ally in the enclave's war against the host: the client wants its messages to be delivered in the right order and without being dropped. The Conclave runtime checks the sequence numbers in the headers always increment before passing the mail to your code. Note The host may arbitrarily delay or even refuse to deliver mail, but it can only end the stream of mails early, it can't re-order messages relative to each other. This is a feature not a bug, as if the enclave could force the host to deliver mail that would imply it had actually taken over the computer somehow and was forcing it to provide services to the enclave. SGX isn't a form of remote control and nobody can force a host to run enclaves against its will. Side channel inspection. Future versions of mail will provide automatic and manual ways to pad messages, so their size can't give away any clues as to their contents. This is in fact one of the benefits of mail: if Conclave couldn't understand the message structure of your app (e.g. because it provided only a stream interface) then it wouldn't be able to do this type of padding.","title":"Attacks on messaging"},{"location":"mail.html#how-does-mail-work","text":"When viewed as a structured array of bytes, a mail consists of five parts: The protocol ID. The unencrypted headers, which have fields simply laid out in order. The unencrypted envelope, which is empty by default and exists for you to add whatever data you like (i.e. additional headers). The handshake. The encrypted body. Let's call the protocol ID, unencrypted headers and envelope the prologue . At the core of Mail's security is the handshake. It consists of the data needed to do an elliptic curve Diffie-Hellman calculation and derive a unique (per mail) AES/GCM key, using the Noise protocol specification . AES/GCM is an authenticated encryption mechanism. That means the key is used not only to encrypt data, but also calculate a special hash called a \"tag\" that allows detection of modifications to the encrypted data. This matters because 'raw' encryption merely stops someone reading a message: if they already know what some parts of the message say (e.g. because it's a well known data structure) then by flipping bits in the encrypted data, corruption can be created in the decrypted message. In some situations these corruptions could change the way the message is parsed leading to an exploit, for example, by changing a zero to a one and gaining administrator access . Like all symmetric ciphers, for AES/GCM to work both sides must know the same key. But we want to be able to send messages to a target for which we only know a public key, and have never had a chance to securely generate a joint AES key with. This is the problem solved by the Elliptic Curve Diffie-Hellman algorithm . To use it we first select a large random number (256 bits) and then convert that to a coordinate on an elliptic curve - in our case, we use Curve25519, which is a modern and highly robust elliptic curve. The point is our public key and can be encoded in another 256 bits (32 bytes). We write this public key after the unencrypted envelope. This key is an ephemeral key - we picked it just for the purposes of creating this mail. We know the target's public key either because the enclave puts it public key into the remote attestation, represented by an EnclaveInstanceInfo object, or because the enclave is replying and obtained the key to reply to from an earlier mail. Two public keys is all that's needed for both parties to compute the same AES key, without any man-in-the-middle being able to calculate the same value. The sender may also have a long term \"static\" public key that the target will recognise. However, at this point we may choose to finish the handshake, either because we are sending a mail anonymously or because the target will recognise us in some other manner than our static key. Alternatively, we may now append an encryption of our long term static public key and repeat the calculation between the enclave's public key and our static key, generating a new AES/GCM key as a result. As each step in the handshake progresses, a running hash is maintained that mixes in the hash of the prologue and the various intermediate stages. This allows the unencrypted headers to be tamper-proofed against the host as well, because the host will not be able to recalculate the authentication tag emitted to the end of the handshake. Thus, in the case where the sender has a long term keypair, the handshake consists of a random public key, an authenticated encryption of the sender's public key, and an authentication hash. Once this is done the mail's AES key has been computed. The initialization vector for each AES encryption is a counter (an exception will be thrown if the mail is so large the counter would wrap around, as that would potentially reveal information for cryptanalysis, however this cannot happen given the maximum mail size). The encrypted body consists of a set of 64kb packets. Each packet has its own authentication tag, thus data is read from a mail in 64kb chunks. Packets may also contain a true length as distinct from the length of the plaintext. This allows the sender to artificially inflate the size of the encrypted message by simply padding it with zeros, which enables hiding of the true message size. Message sizes can be a giveaway to what exact content it contains.","title":"How does Mail work"},{"location":"mail.html#comparison-to-a-classical-architecture-using-rest-and-ssl","text":"Let's look at why Conclave provides Mail, instead of having clients connect into an enclave using HTTPS. Note The following explanation applies when connecting to the enclave . When connecting to the host you may use whatever transport mechanism you like to pass mail around. Conclave doesn't currently privilege any particular transport over any other. We provide the mail paradigm for these reasons: HTTPS requires a relatively large and complex infrastructure, increasing the size of the trusted computing base (TCB). It can go wrong in ways that aren't intuitive. Mail attempts to solve some common security problems before they start. SSL/TLS is not well adapted to enclaves, for example certificates don't make sense, but the protocol requires them. Web servers require the backing of a database to ensure session persistence and atomicity, but this interacts badly with the way enclaves handle time and state. Mail allows for a very simple approach to restarting and upgrading enclaves. The primary reason to use HTTPS+REST is familiarity and installed base of tools. However, none of these tools or libraries understand SGX remote attestation so cannot be used in their regular modes and must be modified or adjusted in complex ways, thus invalidating most of the benefits. We'll now explore these issues in more depth.","title":"Comparison to a classical architecture using REST and SSL"},{"location":"mail.html#tcb-size","text":"The code that handles encrypted messaging is directly exposed to attackers. It is important to minimise the amount of code exposed in this way. For more discussion of how enclaves are designed to minimise code size, please see \"Small is beautiful\" .","title":"TCB size"},{"location":"mail.html#tls-complexity","text":"Mail is based on the Noise protocol framework . Noise is designed by professional cryptographers and is used in WhatsApp, WireGuard and other modern network protocols. Noise was created because TLS is weighed down with complicated historical baggage and web-specific features. A Noise protocol delivers most of the same functionality but in a more modular, cleaner and simpler way. Therefore, outside of the web the primary reason to use TLS is compatibility, not technical excellence. Now there is Noise there isn't much reason to use TLS anymore when designing a new protocol from scratch, unless you really need its features or support. TLS 1.3 recognises this problem and simplifies the protocol, but it's still far more complex than a Noise protocol, and because the purpose of using TLS is compatibility and TLS 1.3 is very new, realistically you will support TLS 1.2 as well. So now you have even more complexity in your enclave because you need both 1.2 and 1.3 support simultaneously. A big source of complexity in TLS is X.509 certificates. Certificates do not make sense for an enclave but TLS absolutely requires them, so some systems try to jam fake pseudo-certificates into TLS, which aren't real but contain the remote attestation in an extension field. Fake certificates can create problems because a lot of organisations have decades of procedures and best practices around all aspects of certificates and X.509, so fake pseudo-certificates can end up harder to deploy and work with than a purely technical analysis would suggest. Noise is more modular - you can provide any arbitrary byte array as part of the handshake, which can thus include a certificate (of any format) if you want that, but it isn't necessary. In Conclave the \"certificate\" is the remote attestation data represented as an EnclaveInstanceInfo object. It will usually make sense to expose this to the client via some app-specific mechanism, for example, returning it in some other API, publishing it on a web server, a network drive, a message queue, even putting it into a distributed hash table. Noise and by extension Conclave doesn't care how you get this data, only that you have it. Certificates don't make sense for enclaves because TLS is all about verifiable names as a form of identity, but enclaves are all about measurements and remote attestations . Thus, any client tool that communicates with an enclave will need to extract a remote attestation from a pseudo-certificate and throw out the rest. Given that you would need complex custom client-side code anyway, TLS buys you little beyond brand recognition. Notice This logic applies when connecting to an enclave . When connecting to a host the domain name identity of the server owner may well matter, and in that case TLS can be useful. TLS stacks have a history of being extremely buggy. The security TLS supposedly adds has a track record of being undermined by bugs in the implementations e.g. Heartbleed. Putting a TLS stack into an enclave makes it much bigger and harder to audit. In Conclave, we could use the JSSE Java SSL implementation and thus avoid memory management errors, but there are other kinds of issues that can be experienced with TLS too, that Java cannot protect us from. We use a pure Java implementation of Noise which ensures there are no buffer overflows in our crypto stack, and it's small enough that we have read every line. By licensing Conclave you can get the code, and then you can read every line too. This is impractical for a TLS stack. Finally, TLS mandates complex session persistence. This is a subtle point that deserves deeper discussion.","title":"TLS complexity"},{"location":"mail.html#sessions-and-forward-secrecy","text":"One of the upgrades Noise gives us is the ability to encrypt in both interactive and one-way modes e.g. for encrypting a file. TLS and HTTPS are fundamentally interactive protocols and cannot do this. TLS is interactive because the modern way to use it (and the only way in TLS 1.3) is with forward secrecy . In a scheme with forward secrecy two sides calculate an ephemeral session symmetric key during the handshake, that is used only for a short period and then deleted - usually this means the ephemeral key is stored only in RAM. In theory this is good, because it means if someone hacks the server/enclave they can't decrypt all the old messages they might have recorded. The private key is used only to establish identity, not actually encrypt any messages. With a purely one-way handshake you don't get this. Forward secrecy is a rather slippery feature. The problem is simple - what does \"short period\" mean? This is surprisingly hard to answer. TLS was designed for the web so at first this meant a TCP connection that carried a few web requests. So, usually a few seconds or perhaps hours if doing a big download. These days it gets used in many other kinds of apps and thus might mean much longer sessions, but fundamentally a TLS session was tied to the lifetime of a socket and therefore it couldn't last very long. Handshaking to set up a new session key is slow, so various optimisations were introduced. Connections were kept alive longer, and TLS added \"session resume\" that allowed session keys to be saved to disk and continued in later connections. For this to actually add any security it has to be harder to steal the cached session keys than the identity keys, but why would this be so when they're both stored in ordinary files ? But there's actually an even deeper conceptual problem. TLS encrypts sockets. It has nothing to say about the wider design of your app - that's out of scope for the people designing TLS. As a consequence TLS sessions don't bear any resemblance to actual user sessions. The intuition behind forward secrecy is a sort of controlled forgetting ... when the session ends the keys that could decrypt it are destroyed, so even if a passive observer stops being passive and hacks someone's private key they can't get the \"forgotten\" data. If web apps forgot everything you uploaded for no better reason than you changed from 4G to Wi-Fi people would get pretty upset. So HTTP has the idea of cookies, but even that is too transient for most users, which is why web apps normally require you to log in to an account. The actual data an attacker cares about is tied to the lifetime of an account, not a TCP connection. To make this work servers must store user session data into a database. This is so obvious and natural we hardly think about it, but it largely obliterates the supposed benefits of forward secrecy - the private key is held on the server, so if you can steal it you can probably steal the database credentials that are also stored on the server. And then you can just steal the valuable user data out of the database, you don't need to decrypt TLS sessions anymore. The biggest risk to an enclave is that the host can read its memory and thus steal its keys. Forward secrecy doesn't help you with this because users (we think) won't tolerate an app that forgets stuff if a TCP connection resets, and operations teams won't tolerate software that can't be safely restarted. So in practice an enclave will immediately re-encrypt data received from a client under a static sealing key, and if you can steal a TLS private key out of an enclave you can also steal a sealing key. So it buys you nothing. Moreover, it's insufficient to simply seal a byte array. You will probably need some sort of minimal database infrastructure, to keep data separated by user and so on. So now you have the complexity of a data management layer in the enclave as well. The result of all this is we don't lose much by using a more asynchronous design in which there isn't an interactive handshake.","title":"Sessions and forward secrecy"},{"location":"mail.html#benefits-of-noise","text":"By losing TLS we can: Eliminate huge complexity from in-enclave code. Avoid pseudo-certificates and other hacks that will open up exploits and hit corporate X.509 bureaucracy. Enable enclaves to talk to each other even if they can't be loaded simultaneously (e.g. on same machine) Move session management and expiry out of the enclave, where it can't be done properly anyway because there's no secure access to the clock. Get various other benefits, like being able to reuse MQ brokers, integrate with Corda flows, store messages to databases, support M-to-1 inbound message collection before processing and so on.","title":"Benefits of Noise"},{"location":"mail.html#messages-vs-streams","text":"There are three main ways for networked programs to communicate: streams, messages and RPCs. The popular REST paradigm is a form of RPC for the purposes of this discussion. Multi-party computations all involve the transmission of relatively small messages, often without needing any immediate reply. For instance, over the course of a day parties may submit a small data structure when a human gets around to it, and get the results back hours later when a deadline or threshold is reached. In other cases submission of data to an enclave may be asynchronous and should not block a business process in case of outage. These requirements are not a good fit for stream-oriented connections that when on top of TCP require app developers to do their own framing (a frequent source of security vulnerabilities), can break due to NAT boxes timing them out, IP address changes, passing through one-way firewalls, require high-availability servers with load balancing, require databases for stored state and so on. With a stream or RPC oriented approach the enclave would be expected to respond to bytes from a client more or less immediately, meaning it has to be always running and would have to persist uploaded data itself. Unfortunately persistence in enclaves is tricky due to the existence of Memento attacks (see \" Handling time and state \"). RPCs (including REST) can be hard to integrate with fully reliable systems that can tolerate restarts at any moment. Because server restarts break connections, in a loosely coupled multi-party system connection-oriented protocols require expensive HA load balancing to ensure users aren't often exposed to errors caused by planned restarts. Even then it isn't possible to eliminate such errors entirely, just reduce their impact. Load balancing in an enclave environment requires special support because the client is intimately aware of the exact CPU the enclave is running on - thus switching a client between servers isn't transparent. Note Future versions of Conclave are planned to add support for enclave clustering. All this suggests the primary paradigm exposed to enclaves should be messages. The host will take care of delivering messages and providing atomic, transactional semantics over them so many kinds of enclaves won't need an encrypted database at all. The untrusted host can also take on the significant burden of moving data around, storing it to disk, sorting it, applying backpressure, exposing to the admin if there are backlogs etc.","title":"Messages vs streams"},{"location":"renewability.html","text":"All tamperproof systems need a way to be re-secured in the field after someone finds a way to breach their security. This property is called renewability. For Intel SGX renewability is obtained via a process called \"TCB recovery\". What is a TCB? \u00b6 The trusted computing base is defined as the set of computing technologies that must be working correctly and not be malicious or compromised for a security system to operate. Obviously the larger a TCB is, the more likely something can go wrong. In SGX the TCB is quite small relative to other such systems. It consists of: The CPU itself, including: The silicon The upgradeable microcode The system enclaves like the 'quoting enclave' which produces material for remote attestation. The runtime code linked into an enclave that's not direct business logic. For Conclave that means: The trts (trusted runtime system) from the Intel Linux SDK. The Conclave JVM and message routing code. Other components you might expect to be a part of the TCB aren't, for instance the operating system isn't, nor is the the BIOS or the aesmd daemon that handles interaction with Intel's remote attestation assessment servers. Only small parts of the SGX infrastructure and code that runs inside enclaves needs to be operating correctly. Intel systems also have a chip called the 'management engine' (ME). Although some SGX apps use capabilities from this chip, Conclave doesn't use any ME services and thus the ME isn't a part of the trusted computing base. Recovering the TCB \u00b6 When bugs or security weaknesses are found the replaceable parts of the TCB are upgraded via normal software updates. The version of the TCB a computer is using is a part of the remote attestation, so enclave clients can check if the operator of an enclave has upgraded their TCB correctly and refuse to upload data if not. In this state the EnclaveInstanceInfo.securityInfoFromServer.summary property will be set to STALE , indicating that the system is running in a secure mode but there are known reasons to upgrade. To perform TCB recovery one or more of the following actions may be required by the owner of the hardware (i.e. either you or your cloud vendor): Applying operating system updates (as these include new microcode) Upgrading Conclave Recompiling the enclave and distributing a new version Altering the BIOS/UEFI configuration In cases where you're running on virtualised hardware, contact your cloud provider to learn about their schedule for performing TCB recoveries. If a new version of Conclave is required that will be communicated to licensees when it becomes available. New versions may also provide more detailed advice on what to do in the EnclaveSecurityInfo object. Converting an EnclaveInstanceInfo object to a string will usually include a textual summary explaining why a machine is judged to be insecure or stale and what can be done to resolve the problem. Timeframes for TCB recovery \u00b6 When a TCB recovery begins Intel announce it via their website. Deadlines are provided at which time remote attestations from non-upgraded systems will become labelled as STALE . This doesn't happen immediately: time is provided with which to implement any required changes and upgrade. This is to avoid apps that require fully upgraded systems from unexpectedly breaking on the day of the security announcements.","title":"Renewability"},{"location":"renewability.html#what-is-a-tcb","text":"The trusted computing base is defined as the set of computing technologies that must be working correctly and not be malicious or compromised for a security system to operate. Obviously the larger a TCB is, the more likely something can go wrong. In SGX the TCB is quite small relative to other such systems. It consists of: The CPU itself, including: The silicon The upgradeable microcode The system enclaves like the 'quoting enclave' which produces material for remote attestation. The runtime code linked into an enclave that's not direct business logic. For Conclave that means: The trts (trusted runtime system) from the Intel Linux SDK. The Conclave JVM and message routing code. Other components you might expect to be a part of the TCB aren't, for instance the operating system isn't, nor is the the BIOS or the aesmd daemon that handles interaction with Intel's remote attestation assessment servers. Only small parts of the SGX infrastructure and code that runs inside enclaves needs to be operating correctly. Intel systems also have a chip called the 'management engine' (ME). Although some SGX apps use capabilities from this chip, Conclave doesn't use any ME services and thus the ME isn't a part of the trusted computing base.","title":"What is a TCB?"},{"location":"renewability.html#recovering-the-tcb","text":"When bugs or security weaknesses are found the replaceable parts of the TCB are upgraded via normal software updates. The version of the TCB a computer is using is a part of the remote attestation, so enclave clients can check if the operator of an enclave has upgraded their TCB correctly and refuse to upload data if not. In this state the EnclaveInstanceInfo.securityInfoFromServer.summary property will be set to STALE , indicating that the system is running in a secure mode but there are known reasons to upgrade. To perform TCB recovery one or more of the following actions may be required by the owner of the hardware (i.e. either you or your cloud vendor): Applying operating system updates (as these include new microcode) Upgrading Conclave Recompiling the enclave and distributing a new version Altering the BIOS/UEFI configuration In cases where you're running on virtualised hardware, contact your cloud provider to learn about their schedule for performing TCB recoveries. If a new version of Conclave is required that will be communicated to licensees when it becomes available. New versions may also provide more detailed advice on what to do in the EnclaveSecurityInfo object. Converting an EnclaveInstanceInfo object to a string will usually include a textual summary explaining why a machine is judged to be insecure or stale and what can be done to resolve the problem.","title":"Recovering the TCB"},{"location":"renewability.html#timeframes-for-tcb-recovery","text":"When a TCB recovery begins Intel announce it via their website. Deadlines are provided at which time remote attestations from non-upgraded systems will become labelled as STALE . This doesn't happen immediately: time is provided with which to implement any required changes and upgrade. This is to avoid apps that require fully upgraded systems from unexpectedly breaking on the day of the security announcements.","title":"Timeframes for TCB recovery"},{"location":"security.html","text":"In this section we discuss some security issues inherent to the enclave model which may not be immediately apparent. Secure time access \u00b6 The trusted computing base is very small in the SGX architecture. Only the CPU and some support software needs to be trusted to work correctly. That means anything else in the computer other than the CPU is assumed to be broken or malicious, and defended against using encryption and authentication. This has implications for reading the system clock. The current time is maintained by a battery powered real-time clock chip outside the CPU, which can be tampered with by the untrusted machine owner at any time. For this reason inside the enclave the current time isn't available. Trying to read it will yield a default, unchanging timestamp. Additionally, the enclave may be paused at any moment for an arbitrary duration without the enclave code being aware of that, so if you were to read a timestamp it might be very old at the moment you actually used it. For these reasons timestamping events requires special support and discussion. Future versions of Conclave will be usable together with Corda , a decentralised ledger technology that provides trusted logical and real-time clocks suitable for ordering database transactions and recording an approximate UTC timestamp at which they occurred. If you need a timestamp without using Corda, you can get a signed timestamp from many sources. For instance doing an HTTP GET request to www.google.com will provide a reading from Google's clocks in the HTTP result headers. Memento attacks \u00b6 Your enclave has protected RAM which it uses to store normal, in-memory data. Reads are guaranteed to observe prior writes. But an enclave is just an ordinary piece of code running in an ordinary program. That means it cannot directly access hardware. Like any other program it has to ask the kernel to handle requests on its behalf, because the kernel is the only program running in the CPU's supervisor mode where hardware can be controlled (\"ring 0\" on Intel architecture chips). In fact, inside an enclave there is no direct access to the operating system at all. The only thing you can do is exchange messages with the host code. The host may choose to relay your requests through the kernel to the hardware honestly, or any of those components (host software, kernel, the hardware itself) may have been modified maliciously. The enclave protections are a feature of the CPU , not the entire computer, and the CPU maintains state only until it is reset or the power is lost. You can think of this another way. If the enclave stores some data to disk, nothing stops the owner of the computer stopping the enclave host process and then editing the files on disk. Because enclaves can generate encryption keys private to themselves, encryption and authentication can be used to stop the host editing the data. Data encrypted in this way is called sealed data . Sealed data can be re-requested from the operating system and decrypted inside the enclave. Conclave handles the sealing process for you. Unfortunately there's one class of attack encryption cannot stop. It must instead be considered in the design of your app. That attack is when the host gives you back older data than was requested. The system clock is controlled by the owner of the computer and so can't be relied on. Additionally the owner can kill and restart the host process whenever they like. Together this means an enclave's sense of time and ordering of events can be tampered with to create confusion. By snapshotting the stored (sealed, encrypted) data an enclave has provided after each network message from a client is delivered, the enclave can be \"rewound\" to any point. Then stored messages from the clients can be replayed back to the enclave in different orders, or with some messages dropped. We call this a Memento attack, after the film in which the protagonist has anterograde amenesia . Warning A full discussion of Memento attacks is beyond the scope of this document. The Conclave project strives to provide you with high level protocol constructs that take them into account, but when writing your own protocols you should consider carefully what happens when messages can be re-ordered and re-tried by the host. Side channel attacks \u00b6 Side channel attacks are a way to break encryption without actually defeating the underlying algorithms, by making very precise observations from the outside of a machine or program doing a secure computation. Those observations may be of timings or power draw fluctuations. Because enclaves run in an environment controlled by an untrusted host, we must assume the operator of the host hardware is doing these kinds of observations in an attempt to break the security of the enclave. Side channel attacks introduce a fundamental tradeoff between performance, scalability and security. A part of Conclave's intended value proposition is to surface these tradeoffs to you in a way that's easy to understand and control, whilst blocking as many attacks as possible automatically. Side channel attacks on enclaves can be divided into two categories: Architectural Micro-architectural These types are discussed more below. Because side channel attacks present tradeoffs between privacy and performance, analysing them requires a different mindset to normal security analysis. Formally, we can say a secret has been leaked via a side channel if we can learn even a single binary bit of data about an encrypted message. However often the leaked data doesn't matter or isn't a secret worth protecting. In these cases it may be better to allow a limited amount of leakage to obtain better performance. Future versions of this guide and the Conclave API will assist you in studying and making these tradeoffs. A standard example is whether a message is of type A or type B, under the assumption that most apps have at least two kinds of message that an enclave can process from clients. Careful requirements analysis may reveal that the number or sequencing of message types doesn't reveal any important information and thus doesn't need to be protected: only the specific data within the messages. Architectural attacks \u00b6 Architectural side channel attacks exploit the nature, structure or specific code of your application architecture to reveal secrets. Here is a non-exhaustive set of examples: Message sizes . If your enclave is known to process only two kinds of message of around 1 kilobyte or 100 kilobytes respectively, then the size of the encrypted message by itself leaks information about what kind of message it is. Message processing time . The same as message sizes but with processing time, e.g. a message type that takes 1msec to process vs 100 msec can leak what kind of message it is by simply observing how much work the enclave does when the host passes it the new data. Storage access patterns . If your enclave doesn't access the database when processing a message of type A but does when processing a message of type B, or accesses the database with a different sequence, number or type of accesses, the host can learn the message type by observing those accesses. Many of these techniques can be used to reveal fine grained information, not just message types. For instance if an encrypted piece of data contains a number that's then used to control a loop that does data lookups, counting the number of external data lookups reveals the number. Some kinds of architectural side channel attacks can be mitigated by Conclave for you, for instance, messages can be padded so all encrypted messages look the same size. This sort of approach works if message sizes don't vary too wildly and you can afford to use the bandwidth and storage to set all messages to their maximum possible size. How valuable it is in your situation is a topic for you to consider as you design your app. Micro-architectural \u00b6 Enclave memory is encrypted. Micro-architectural side channel attacks exploit the inner workings of the CPU itself to reveal information whilst it's being processed by the CPU in its normal unencrypted state. There are a variety of different attacks with varying details. They work by exploiting the speculative execution capability of the processor to make an enclave compute on invalid data, which can then be used to bypass normal security mechanisms and leak data out of the enclave - not via normal means (which the CPU doesn't allow) but by affecting the timing of subsequent operations which can then be measured. Micro-architectural side channel attacks can be resolved at a layer lower than the architecture of your own application. They often require reducing the performance of either the enclave or the entire host system however, so it's worth always planning for a large buffer of unused per-host performance. The mitigations suggested for the latest round of micro-architectural side channel attacks (load value injection or LVI attacks) work by effectively disabling speculative execution when in enclave mode. Combined with the overhead of memory encryption, execution inside an enclave can run a lot slower than normal software running outside. Impact of side channel attacks \u00b6 Not all enclaves operate on secret data. Some types of enclave are used for their auditable execution rather than to work with secret data unaccessible to the host. For those kinds of enclave it's sufficient to protect the signing keys rather than all data the enclave accesses. Other types of enclave work purely with secret data, but expect that the host isn't normally malicious: in this scenario enclaves are being used to slow down or stop attackers in the face of a hacked host network. It thus makes up one part of a standard suite of security measures. Because the performance/privacy tradeoff presented by side channel attacks can vary so widely, and this is an active area of academic research, the expectation is that every new Conclave version will provide new tools and tunable settings to control their impact. This will continue for the lifespan of the product. As a developer it's your responsibility to both upgrade to new versions as they come out, and to take side channels into account when planning the architecture and capacity needs of your application.","title":"Security discussion"},{"location":"security.html#secure-time-access","text":"The trusted computing base is very small in the SGX architecture. Only the CPU and some support software needs to be trusted to work correctly. That means anything else in the computer other than the CPU is assumed to be broken or malicious, and defended against using encryption and authentication. This has implications for reading the system clock. The current time is maintained by a battery powered real-time clock chip outside the CPU, which can be tampered with by the untrusted machine owner at any time. For this reason inside the enclave the current time isn't available. Trying to read it will yield a default, unchanging timestamp. Additionally, the enclave may be paused at any moment for an arbitrary duration without the enclave code being aware of that, so if you were to read a timestamp it might be very old at the moment you actually used it. For these reasons timestamping events requires special support and discussion. Future versions of Conclave will be usable together with Corda , a decentralised ledger technology that provides trusted logical and real-time clocks suitable for ordering database transactions and recording an approximate UTC timestamp at which they occurred. If you need a timestamp without using Corda, you can get a signed timestamp from many sources. For instance doing an HTTP GET request to www.google.com will provide a reading from Google's clocks in the HTTP result headers.","title":"Secure time access"},{"location":"security.html#memento-attacks","text":"Your enclave has protected RAM which it uses to store normal, in-memory data. Reads are guaranteed to observe prior writes. But an enclave is just an ordinary piece of code running in an ordinary program. That means it cannot directly access hardware. Like any other program it has to ask the kernel to handle requests on its behalf, because the kernel is the only program running in the CPU's supervisor mode where hardware can be controlled (\"ring 0\" on Intel architecture chips). In fact, inside an enclave there is no direct access to the operating system at all. The only thing you can do is exchange messages with the host code. The host may choose to relay your requests through the kernel to the hardware honestly, or any of those components (host software, kernel, the hardware itself) may have been modified maliciously. The enclave protections are a feature of the CPU , not the entire computer, and the CPU maintains state only until it is reset or the power is lost. You can think of this another way. If the enclave stores some data to disk, nothing stops the owner of the computer stopping the enclave host process and then editing the files on disk. Because enclaves can generate encryption keys private to themselves, encryption and authentication can be used to stop the host editing the data. Data encrypted in this way is called sealed data . Sealed data can be re-requested from the operating system and decrypted inside the enclave. Conclave handles the sealing process for you. Unfortunately there's one class of attack encryption cannot stop. It must instead be considered in the design of your app. That attack is when the host gives you back older data than was requested. The system clock is controlled by the owner of the computer and so can't be relied on. Additionally the owner can kill and restart the host process whenever they like. Together this means an enclave's sense of time and ordering of events can be tampered with to create confusion. By snapshotting the stored (sealed, encrypted) data an enclave has provided after each network message from a client is delivered, the enclave can be \"rewound\" to any point. Then stored messages from the clients can be replayed back to the enclave in different orders, or with some messages dropped. We call this a Memento attack, after the film in which the protagonist has anterograde amenesia . Warning A full discussion of Memento attacks is beyond the scope of this document. The Conclave project strives to provide you with high level protocol constructs that take them into account, but when writing your own protocols you should consider carefully what happens when messages can be re-ordered and re-tried by the host.","title":"Memento attacks"},{"location":"security.html#side-channel-attacks","text":"Side channel attacks are a way to break encryption without actually defeating the underlying algorithms, by making very precise observations from the outside of a machine or program doing a secure computation. Those observations may be of timings or power draw fluctuations. Because enclaves run in an environment controlled by an untrusted host, we must assume the operator of the host hardware is doing these kinds of observations in an attempt to break the security of the enclave. Side channel attacks introduce a fundamental tradeoff between performance, scalability and security. A part of Conclave's intended value proposition is to surface these tradeoffs to you in a way that's easy to understand and control, whilst blocking as many attacks as possible automatically. Side channel attacks on enclaves can be divided into two categories: Architectural Micro-architectural These types are discussed more below. Because side channel attacks present tradeoffs between privacy and performance, analysing them requires a different mindset to normal security analysis. Formally, we can say a secret has been leaked via a side channel if we can learn even a single binary bit of data about an encrypted message. However often the leaked data doesn't matter or isn't a secret worth protecting. In these cases it may be better to allow a limited amount of leakage to obtain better performance. Future versions of this guide and the Conclave API will assist you in studying and making these tradeoffs. A standard example is whether a message is of type A or type B, under the assumption that most apps have at least two kinds of message that an enclave can process from clients. Careful requirements analysis may reveal that the number or sequencing of message types doesn't reveal any important information and thus doesn't need to be protected: only the specific data within the messages.","title":"Side channel attacks"},{"location":"security.html#architectural-attacks","text":"Architectural side channel attacks exploit the nature, structure or specific code of your application architecture to reveal secrets. Here is a non-exhaustive set of examples: Message sizes . If your enclave is known to process only two kinds of message of around 1 kilobyte or 100 kilobytes respectively, then the size of the encrypted message by itself leaks information about what kind of message it is. Message processing time . The same as message sizes but with processing time, e.g. a message type that takes 1msec to process vs 100 msec can leak what kind of message it is by simply observing how much work the enclave does when the host passes it the new data. Storage access patterns . If your enclave doesn't access the database when processing a message of type A but does when processing a message of type B, or accesses the database with a different sequence, number or type of accesses, the host can learn the message type by observing those accesses. Many of these techniques can be used to reveal fine grained information, not just message types. For instance if an encrypted piece of data contains a number that's then used to control a loop that does data lookups, counting the number of external data lookups reveals the number. Some kinds of architectural side channel attacks can be mitigated by Conclave for you, for instance, messages can be padded so all encrypted messages look the same size. This sort of approach works if message sizes don't vary too wildly and you can afford to use the bandwidth and storage to set all messages to their maximum possible size. How valuable it is in your situation is a topic for you to consider as you design your app.","title":"Architectural attacks"},{"location":"security.html#micro-architectural","text":"Enclave memory is encrypted. Micro-architectural side channel attacks exploit the inner workings of the CPU itself to reveal information whilst it's being processed by the CPU in its normal unencrypted state. There are a variety of different attacks with varying details. They work by exploiting the speculative execution capability of the processor to make an enclave compute on invalid data, which can then be used to bypass normal security mechanisms and leak data out of the enclave - not via normal means (which the CPU doesn't allow) but by affecting the timing of subsequent operations which can then be measured. Micro-architectural side channel attacks can be resolved at a layer lower than the architecture of your own application. They often require reducing the performance of either the enclave or the entire host system however, so it's worth always planning for a large buffer of unused per-host performance. The mitigations suggested for the latest round of micro-architectural side channel attacks (load value injection or LVI attacks) work by effectively disabling speculative execution when in enclave mode. Combined with the overhead of memory encryption, execution inside an enclave can run a lot slower than normal software running outside.","title":"Micro-architectural"},{"location":"security.html#impact-of-side-channel-attacks","text":"Not all enclaves operate on secret data. Some types of enclave are used for their auditable execution rather than to work with secret data unaccessible to the host. For those kinds of enclave it's sufficient to protect the signing keys rather than all data the enclave accesses. Other types of enclave work purely with secret data, but expect that the host isn't normally malicious: in this scenario enclaves are being used to slow down or stop attackers in the face of a hacked host network. It thus makes up one part of a standard suite of security measures. Because the performance/privacy tradeoff presented by side channel attacks can vary so widely, and this is an active area of academic research, the expectation is that every new Conclave version will provide new tools and tunable settings to control their impact. This will continue for the lifespan of the product. As a developer it's your responsibility to both upgrade to new versions as they come out, and to take side channels into account when planning the architecture and capacity needs of your application.","title":"Impact of side channel attacks"},{"location":"signing.html","text":"Enclaves must be signed in order to be loaded. This section covers: Why is signing required Who can sign enclaves How to sign your enclaves Why is signing required? \u00b6 Signing requirements are a part of the Intel SGX architecture. The enclave signature is used for two different purposes: Linking different enclave versions together into an upgrade path, so new enclaves can decrypt data stored by or sent to old enclaves. Authorising which enclaves can be executed on a host. Restricting which enclaves can launch on a host ensures that datacenter providers aren't hosting server processes they can't examine or turn over to law enforcement. It also makes it harder for people to write malware with un-debuggable cores, and is part of the privacy (anti-tracking) infrastructure in SGX. Using signatures to link binaries into a single upgrade path is the same technique used by Android and iOS to move permissions and stored data from old to new apps. Signing is also used to authorise which enclaves can start. Intel chips won't start an enclave unless it's signed by a key recognised by a launch approver. Who can sign \u00b6 On the most common kind of hardware, permission from Intel is required to create a launchable enclave. Getting whitelisted is free and can be done quickly. It's a similar process to getting an SSL certificate but using different tools. On Xeon E CPUs with Intel SPS support in the chipset, and a recent enough kernel driver, the owner can add their own whitelisting authorities via BIOS/UEFI firmware settings. This means they can whitelist their own enclaves / enclave vendors. Current Conclave versions aren't able to use this capability at present. To run in production (fully secured) mode you need a whitelisted Intel key. We plan to implement support for the flexible launch control feature in future versions. At this time not much shipping hardware supports it however, so for near term uses you should plan on getting a whitelisted Intel key. How to sign your enclaves \u00b6 Signing keys for simulation and debug enclaves \u00b6 It is not necessary to use a whitelisted signature for enclaves built in simulation and debug modes. However, it is still required that these enclaves are signed. Conclave supports the generation of a dummy key during the build process that can be used for signing simulation and debug enclaves. Obtaining a signing key for release enclaves \u00b6 Firstly, get a commercial license . This is a lightweight process and doesn't cost anything or impose other requirements. Following the instructions provided on that page should allow you to get a signing key. Tip It's up to you whether or not to store the key in an HSM. Signing configurations \u00b6 There are three different configurations available for signing enclaves using Conclave: Using a dummy key Using a private key Using an external process such as a signing service or HSM Dummy keys are only useful for signing simulation and debug enclaves. A release enclave signed with a dummy key will not be whitelisted on any platform so will not be allowed to load. A private key can be used to sign enclaves directly within the build process. The key must be accessible on the filesystem of the machine building the enclave. An external process is used when the signing key is not available on the machine building the enclave, or a manual or air-gapped process is required to sign the enclave. In this case the Conclave project is built in two steps. The first step generates the material to be signed. The second step provides the signed material to the Conclave build to continue and complete the build process. How to configure signing for your enclaves \u00b6 The signing method used by your enclaves is configured in the build.gradle file for your enclave project. You can specify different signing settings for simulation, debug and release in the same project. The signing configuration is specified inside the relevant enclave type inside the conclave configuration. For example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 conclave { simulation { // Simulation signing configuration using a dummy key signingType = dummyKey } debug { // Debug signing configuration using a private key signingType = privateKey signingKey = file ( \"../signing/sample_private_key.pem\" ) } release { // Release signing configuration using an external key signingType = externalKey mrsignerSignature = file ( \"../signing/signature.bin\" ) mrsignerPublicKey = file ( \"../signing/external_signing_public.pem\" ) signatureDate = new Date ( 1970 , 0 , 1 ) } } For simulation and debug enclaves signingType defaults to dummyKey so the configuration can be optionally omitted. Release enclaves default to having a signingType of externalKey so the configuration parameters for the external signing type must be specified. Alternatively the signingType can be changed to a different type. Note Changing the signing type of a release enclave to dummyKey will result in an enclave that cannot be used as it will never be whitelisted on an SGX platform. The configuration consists of a set of properties which depend on the signing type. Dummy Key \u00b6 Property Value signingType Must be set to dummyKey . This is the default signing type for simulation and debug enclaves. Private Key \u00b6 Property Value signingType Must be set to privateKey . signingKey The file that contains the private key to use when signing the enclave. This can be an absolute path or relative to the enclave project directory. External Key \u00b6 Property Value signingType Must be set to externalKey . This is the default signing type for release enclaves. signatureDate Specifies the date to be embedded in the material generated in the first stage of the external key signing process. signingMaterial The file that that Conclave will generate when preparing an enclave for signing in the first stage of the external key signing process. The resulting file needs to be signed by the external signing process. This can be an absolute path or relative to the enclave project directory. If this is omitted then the default filename of build/enclave/[Simulation|Debug|Release]/signing_material.bin is used mrsignerPublicSignature Used in the second part of the external key process to specify the file containing the signature generated by the external signing process. This can be an absolute path or relative to the enclave project directory. mrsignerPublicKey Used in the second part of the external key process to specify the file containing the public part of the key that was used to externally sign the signing material. This can be an absolute path or relative to the enclave project directory. Generating keys for signing an enclave \u00b6 When using privateKey or externalKey signing types you can create your own keys for testing or production: Creating an RSA private key suitable for signing enclaves \u00b6 The generated key can be used to sign enclaves using the privateKey or externalKey signing types. When using the externalKey type you will need to generate the public key from the private key. 1 openssl genrsa -out my_private_key.pem -3 3072 Creating a password protected RSA private key suitable for signing enclaves \u00b6 The generated key can only be used for the externalKey signing type as it prompts for a password during use. 1 openssl genrsa -aes128 -out my_private_key.pem -3 3072 Obtaining the public key from a private key \u00b6 The public key is required for the externalKey signing type. 1 openssl rsa -in my_private_key.pem -pubout -out my_public_key.pem Building a signed enclave \u00b6 Signing is performed automatically during the build process when using a dummy or private key. Additional steps are required when using an external key. Add the prepareForSigning task to the host build.gradle \u00b6 This is an optional but recommended step to create a more consistent calling convention for invoking Gradle. It adds a Gradle task that can be called regardless of the build type of the enclave. Add the following code to your host build.gradle file. This adds a new Gradle task that can be used to generate the material that will be signed by the external signing process. 1 2 3 tasks . register ( \"prepareForSigning\" ) { it . dependsOn ( \":enclave:generateEnclaveSigningMaterial\" + mode . capitalize ()) } The task works by using the mode Gradle property, which is set to one of simulation , debug or release depending on which enclave type is currently being built, to set a dependency on the relevant Conclave task that generates the signing material. The task makes the following two Gradle invocations equivalent: 1 2 ./gradlew prepareForSigning -PenclaveMode=\"Release\" ./gradlew :enclave:generateEnclaveSigningMaterialRelease See the tutorial and the hello-world sample in the Conclave SDK for an example of this configuration. Generate the signing material \u00b6 Invoke Gradle to generate the files that need to be signed by the external signing process. 1 ./gradlew prepareForSigning -PenclaveMode=\"Release\" The output of this stage is a file that contains the material to be signed in enclave/build/enclave/Release/signing_material.bin Sign the material \u00b6 Perform the required steps to manually sign the file generated in the previous step. This might require copying the file onto a different platform or onto an HSM to generate the signed file. As an example, given a private key the following command can be used to sign the file: 1 openssl dgst -sha256 -out signature.bin -sign my_private_key.pem -keyform PEM signing_material.bin Once completed, copy the signed file and the public key back onto the build system into the location specified in the mrsignerPublicSignature and mrsignerPublicKey properties in the enclave signing configuration. Complete the build \u00b6 Invoke Gradle to complete the build. 1 ./gradlew build -PenclaveMode=\"Release\"","title":"Enclave signing"},{"location":"signing.html#why-is-signing-required","text":"Signing requirements are a part of the Intel SGX architecture. The enclave signature is used for two different purposes: Linking different enclave versions together into an upgrade path, so new enclaves can decrypt data stored by or sent to old enclaves. Authorising which enclaves can be executed on a host. Restricting which enclaves can launch on a host ensures that datacenter providers aren't hosting server processes they can't examine or turn over to law enforcement. It also makes it harder for people to write malware with un-debuggable cores, and is part of the privacy (anti-tracking) infrastructure in SGX. Using signatures to link binaries into a single upgrade path is the same technique used by Android and iOS to move permissions and stored data from old to new apps. Signing is also used to authorise which enclaves can start. Intel chips won't start an enclave unless it's signed by a key recognised by a launch approver.","title":"Why is signing required?"},{"location":"signing.html#who-can-sign","text":"On the most common kind of hardware, permission from Intel is required to create a launchable enclave. Getting whitelisted is free and can be done quickly. It's a similar process to getting an SSL certificate but using different tools. On Xeon E CPUs with Intel SPS support in the chipset, and a recent enough kernel driver, the owner can add their own whitelisting authorities via BIOS/UEFI firmware settings. This means they can whitelist their own enclaves / enclave vendors. Current Conclave versions aren't able to use this capability at present. To run in production (fully secured) mode you need a whitelisted Intel key. We plan to implement support for the flexible launch control feature in future versions. At this time not much shipping hardware supports it however, so for near term uses you should plan on getting a whitelisted Intel key.","title":"Who can sign"},{"location":"signing.html#how-to-sign-your-enclaves","text":"","title":"How to sign your enclaves"},{"location":"signing.html#signing-keys-for-simulation-and-debug-enclaves","text":"It is not necessary to use a whitelisted signature for enclaves built in simulation and debug modes. However, it is still required that these enclaves are signed. Conclave supports the generation of a dummy key during the build process that can be used for signing simulation and debug enclaves.","title":"Signing keys for simulation and debug enclaves"},{"location":"signing.html#obtaining-a-signing-key-for-release-enclaves","text":"Firstly, get a commercial license . This is a lightweight process and doesn't cost anything or impose other requirements. Following the instructions provided on that page should allow you to get a signing key. Tip It's up to you whether or not to store the key in an HSM.","title":"Obtaining a signing key for release enclaves"},{"location":"signing.html#signing-configurations","text":"There are three different configurations available for signing enclaves using Conclave: Using a dummy key Using a private key Using an external process such as a signing service or HSM Dummy keys are only useful for signing simulation and debug enclaves. A release enclave signed with a dummy key will not be whitelisted on any platform so will not be allowed to load. A private key can be used to sign enclaves directly within the build process. The key must be accessible on the filesystem of the machine building the enclave. An external process is used when the signing key is not available on the machine building the enclave, or a manual or air-gapped process is required to sign the enclave. In this case the Conclave project is built in two steps. The first step generates the material to be signed. The second step provides the signed material to the Conclave build to continue and complete the build process.","title":"Signing configurations"},{"location":"signing.html#how-to-configure-signing-for-your-enclaves","text":"The signing method used by your enclaves is configured in the build.gradle file for your enclave project. You can specify different signing settings for simulation, debug and release in the same project. The signing configuration is specified inside the relevant enclave type inside the conclave configuration. For example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 conclave { simulation { // Simulation signing configuration using a dummy key signingType = dummyKey } debug { // Debug signing configuration using a private key signingType = privateKey signingKey = file ( \"../signing/sample_private_key.pem\" ) } release { // Release signing configuration using an external key signingType = externalKey mrsignerSignature = file ( \"../signing/signature.bin\" ) mrsignerPublicKey = file ( \"../signing/external_signing_public.pem\" ) signatureDate = new Date ( 1970 , 0 , 1 ) } } For simulation and debug enclaves signingType defaults to dummyKey so the configuration can be optionally omitted. Release enclaves default to having a signingType of externalKey so the configuration parameters for the external signing type must be specified. Alternatively the signingType can be changed to a different type. Note Changing the signing type of a release enclave to dummyKey will result in an enclave that cannot be used as it will never be whitelisted on an SGX platform. The configuration consists of a set of properties which depend on the signing type.","title":"How to configure signing for your enclaves"},{"location":"signing.html#dummy-key","text":"Property Value signingType Must be set to dummyKey . This is the default signing type for simulation and debug enclaves.","title":"Dummy Key"},{"location":"signing.html#private-key","text":"Property Value signingType Must be set to privateKey . signingKey The file that contains the private key to use when signing the enclave. This can be an absolute path or relative to the enclave project directory.","title":"Private Key"},{"location":"signing.html#external-key","text":"Property Value signingType Must be set to externalKey . This is the default signing type for release enclaves. signatureDate Specifies the date to be embedded in the material generated in the first stage of the external key signing process. signingMaterial The file that that Conclave will generate when preparing an enclave for signing in the first stage of the external key signing process. The resulting file needs to be signed by the external signing process. This can be an absolute path or relative to the enclave project directory. If this is omitted then the default filename of build/enclave/[Simulation|Debug|Release]/signing_material.bin is used mrsignerPublicSignature Used in the second part of the external key process to specify the file containing the signature generated by the external signing process. This can be an absolute path or relative to the enclave project directory. mrsignerPublicKey Used in the second part of the external key process to specify the file containing the public part of the key that was used to externally sign the signing material. This can be an absolute path or relative to the enclave project directory.","title":"External Key"},{"location":"signing.html#generating-keys-for-signing-an-enclave","text":"When using privateKey or externalKey signing types you can create your own keys for testing or production:","title":"Generating keys for signing an enclave"},{"location":"signing.html#creating-an-rsa-private-key-suitable-for-signing-enclaves","text":"The generated key can be used to sign enclaves using the privateKey or externalKey signing types. When using the externalKey type you will need to generate the public key from the private key. 1 openssl genrsa -out my_private_key.pem -3 3072","title":"Creating an RSA private key suitable for signing enclaves"},{"location":"signing.html#creating-a-password-protected-rsa-private-key-suitable-for-signing-enclaves","text":"The generated key can only be used for the externalKey signing type as it prompts for a password during use. 1 openssl genrsa -aes128 -out my_private_key.pem -3 3072","title":"Creating a password protected RSA private key suitable for signing enclaves"},{"location":"signing.html#obtaining-the-public-key-from-a-private-key","text":"The public key is required for the externalKey signing type. 1 openssl rsa -in my_private_key.pem -pubout -out my_public_key.pem","title":"Obtaining the public key from a private key"},{"location":"signing.html#building-a-signed-enclave","text":"Signing is performed automatically during the build process when using a dummy or private key. Additional steps are required when using an external key.","title":"Building a signed enclave"},{"location":"signing.html#add-the-prepareforsigning-task-to-the-host-buildgradle","text":"This is an optional but recommended step to create a more consistent calling convention for invoking Gradle. It adds a Gradle task that can be called regardless of the build type of the enclave. Add the following code to your host build.gradle file. This adds a new Gradle task that can be used to generate the material that will be signed by the external signing process. 1 2 3 tasks . register ( \"prepareForSigning\" ) { it . dependsOn ( \":enclave:generateEnclaveSigningMaterial\" + mode . capitalize ()) } The task works by using the mode Gradle property, which is set to one of simulation , debug or release depending on which enclave type is currently being built, to set a dependency on the relevant Conclave task that generates the signing material. The task makes the following two Gradle invocations equivalent: 1 2 ./gradlew prepareForSigning -PenclaveMode=\"Release\" ./gradlew :enclave:generateEnclaveSigningMaterialRelease See the tutorial and the hello-world sample in the Conclave SDK for an example of this configuration.","title":"Add the prepareForSigning task to the host build.gradle"},{"location":"signing.html#generate-the-signing-material","text":"Invoke Gradle to generate the files that need to be signed by the external signing process. 1 ./gradlew prepareForSigning -PenclaveMode=\"Release\" The output of this stage is a file that contains the material to be signed in enclave/build/enclave/Release/signing_material.bin","title":"Generate the signing material"},{"location":"signing.html#sign-the-material","text":"Perform the required steps to manually sign the file generated in the previous step. This might require copying the file onto a different platform or onto an HSM to generate the signed file. As an example, given a private key the following command can be used to sign the file: 1 openssl dgst -sha256 -out signature.bin -sign my_private_key.pem -keyform PEM signing_material.bin Once completed, copy the signed file and the public key back onto the build system into the location specified in the mrsignerPublicSignature and mrsignerPublicKey properties in the enclave signing configuration.","title":"Sign the material"},{"location":"signing.html#complete-the-build","text":"Invoke Gradle to complete the build. 1 ./gradlew build -PenclaveMode=\"Release\"","title":"Complete the build"},{"location":"tutorial.html","text":"First enclave \u00b6 Important You need the Conclave SDK. If you don't have it please contact R3 and request a trial . This tutorial assumes you've read and understood the conceptual overview . You can find a sample app in the hello-world directory of your SDK. You can use this app as a template for your own if you want a quick start. We will cover: How to set up your machine. How to compile and run the sample app. How to write the sample app . Setting up your machine \u00b6 You need Java 8 or 11 (your choice) and Gradle, so make sure you've installed those first. Alternatively use an IDE like IntelliJ IDEA, which can download and set up both Gradle and the Java Development Kit (JDK) for you. Currently, we support developing enclaves on Windows, macOS and Linux. However, there are a few platform specific differences to be aware of. Firstly, if you plan on building enclaves using the graalvm_native_image runtime (which is the default) on Windows and macOS you will need to install Docker. The graalvm_native_image build process requires access to a Linux build environment which Conclave can automatically configure during the build for you if Docker is installed. If you do not have Docker installed then you can still build enclaves targeting the avian runtime on Windows and macOS. Secondly, executing enclaves without using the \"mock mode\" requires Linux or a Linux container (e.g. via Docker or Windows Subsystem for Linux) and there are no plans to change this. Apple doesn't support SGX and the Windows API support is too limited for use at this time. Instructions are provided below to show you how to use Docker on Windows and macOS to run your enclaves in \"simulation mode\". Alternatively, for day to day development the mock API is plenty sufficient and allows you to debug into enclave calls as well. Compiling a real enclave is only needed for integration testing or real deployment. Enclaves can run in simulation mode without requiring any special setup of Linux or SGX capable hardware. However you of course get no hardware protections. To run against real SGX hardware you must perform some additional machine setup . Compiling the sample enclave \u00b6 Step 1: Import the project Step 2: Look at the Conclave SDK's top level directory Step 3: Click \"import\" when notified that there's a Gradle build script Step 4: If on Linux or Windows, double-click on :host:assemble . Voila! You have just built your first enclave. Now explore the build folder. As normal with Gradle, the assemble task has bundled the program into a zip, with startup scripts. These scripts are nothing special - they just set up the classpath. You could also e.g. make a fat JAR if you want. Running the host and client \u00b6 You will need Linux to test your enclave. Just run the host app like any app - no special startup scripts or setup is required with Conclave! 1 2 3 cd host/build/distributions tar xvf host.tar ./host/bin/host If your Linux machine doesn't have SGX, you should see something like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 This platform does not support hardware enclaves: SGX_DISABLED_UNSUPPORTED_CPU: SGX is not supported by the CPU in this system This attestation requires 2163 bytes. Remote attestation for enclave F86798C4B12BE12073B87C3F57E66BCE7A541EE3D0DDA4FE8853471139C9393F: - Mode: SIMULATION - Code signing key hash: 01280A6F7EAC8799C5CFDB1F11FF34BC9AE9A5BC7A7F7F54C77475F445897E3B - Public signing key: 302A300506032B65700321000568034F335BE25386FD405A5997C25F49508AA173E0B413113F9A80C9BBF542 - Public encryption key: A0227D6D11078AAB73407D76DB9135C0D43A22BEACB0027D166937C18C5A7973 - Product ID: 1 - Revocation level: 0 Assessed security level at 2020-07-17T16:31:51.894697Z is INSECURE - Enclave is running in simulation mode. Reversing Hello World!: !dlrow olleH Listening on port 9999. Use the client app to send strings for reversal. The host has loaded the enclave, obtained its remote attestation (the EnclaveInstanceInfo object), printed it out, asked the enclave to reverse a string and finally opened up a TCP port which will now listen for requests from remote clients. So, let's run the client app: 1 ./gradlew client:run --args = \"reverse me!\" The client will connect to the host, download the EnclaveInstanceInfo , check it, and then send an encrypted string to reverse. The host will deliver this encrypted string to the enclave, and the enclave will send back to the client the encrypted reversed response: 1 2 3 4 Reading a remote attestation of length 2163 bytes. Sending the encrypted mail to the host. Reading reply mail of length 196 bytes. Enclave reversed 'reverse me!' and gave us the answer '!em esrever' Try this: 1 ./gradlew client:run --args = \"aibohphobia\" Tip Aibohphobia is the fear of palindromes. Testing on Windows and macOS \u00b6 The easiest way to test your code is always to use the mock environment. This runs everything inside the host JVM and thus gives high performance, cross platform portability and full debugging support, as all the SGX infrastructure is kept out of the way. However, it means you aren't testing on the same JVM that will be used in the enclave. To create and run a real enclave on Windows or macOS you will need to run the host on a Linux virtual machine with a simulation mode enclave. The easiest way to do this is to use Docker, which is integrated with Conclave and hides the virtual machine setup from you. Install Docker and then follow these instructions. Tip If you are using the avian runtime then you may need to run this command in the root of your Gradle project first: gradlew setupLinuxExecEnvironment . You don't need to do this if you use the graalvm_native_image runtime. The following command creates a temporary Docker container that mounts the current directory then runs the host within the container. The container is automatically stopped and removed after the host exits. The host may use port 8080 for networking. Note that this command should be run from the root of your Gradle project, assuming your host program is in a module called host - adjust the paths if not. Windows PowerShell 1 docker run -t --rm -p 8080:8080 -v ${ PWD } :/project -w /project conclave-build ./host/build/install/host/bin/host macOS Terminal 1 docker run -t -p 8080:8080 --rm -v $PWD:/project -w /project --user $(id -u):$(id -g) conclave-build ./host/build/install/host/bin/host You may want to create an IntelliJ launch configuration to automatically rebuild the host and enclave (if needed) before running the host in the container. Put the command above in a .cmd batch file (Windows) or a .sh file (macOS) and then use the \"Shell script\" launch configuration type, and add a Gradle task in the \"Before launch\" section. You should make it depend on the host's installDist target. You will then be able to click the run icon in your IDE to build and start up the Java host app inside the Docker container. If on macOS and on a version of IntelliJ before 2020.3 you can set the default interpreter to exec - this will make IntelliJ complain when you try to save or run it, but if you bypass those warnings it will cause the terminal tab to close when the host exits, which keeps your terminal area clean. Versions of IntelliJ after 2020.3 don't need this as they provide a check box to control whether the host will be in a Run tab or a terminal tab. If you get stuck please contact conclave-discuss@groups.io and ask for help!","title":"Compiling and running"},{"location":"tutorial.html#first-enclave","text":"Important You need the Conclave SDK. If you don't have it please contact R3 and request a trial . This tutorial assumes you've read and understood the conceptual overview . You can find a sample app in the hello-world directory of your SDK. You can use this app as a template for your own if you want a quick start. We will cover: How to set up your machine. How to compile and run the sample app. How to write the sample app .","title":"First enclave"},{"location":"tutorial.html#setting-up-your-machine","text":"You need Java 8 or 11 (your choice) and Gradle, so make sure you've installed those first. Alternatively use an IDE like IntelliJ IDEA, which can download and set up both Gradle and the Java Development Kit (JDK) for you. Currently, we support developing enclaves on Windows, macOS and Linux. However, there are a few platform specific differences to be aware of. Firstly, if you plan on building enclaves using the graalvm_native_image runtime (which is the default) on Windows and macOS you will need to install Docker. The graalvm_native_image build process requires access to a Linux build environment which Conclave can automatically configure during the build for you if Docker is installed. If you do not have Docker installed then you can still build enclaves targeting the avian runtime on Windows and macOS. Secondly, executing enclaves without using the \"mock mode\" requires Linux or a Linux container (e.g. via Docker or Windows Subsystem for Linux) and there are no plans to change this. Apple doesn't support SGX and the Windows API support is too limited for use at this time. Instructions are provided below to show you how to use Docker on Windows and macOS to run your enclaves in \"simulation mode\". Alternatively, for day to day development the mock API is plenty sufficient and allows you to debug into enclave calls as well. Compiling a real enclave is only needed for integration testing or real deployment. Enclaves can run in simulation mode without requiring any special setup of Linux or SGX capable hardware. However you of course get no hardware protections. To run against real SGX hardware you must perform some additional machine setup .","title":"Setting up your machine"},{"location":"tutorial.html#compiling-the-sample-enclave","text":"Step 1: Import the project Step 2: Look at the Conclave SDK's top level directory Step 3: Click \"import\" when notified that there's a Gradle build script Step 4: If on Linux or Windows, double-click on :host:assemble . Voila! You have just built your first enclave. Now explore the build folder. As normal with Gradle, the assemble task has bundled the program into a zip, with startup scripts. These scripts are nothing special - they just set up the classpath. You could also e.g. make a fat JAR if you want.","title":"Compiling the sample enclave"},{"location":"tutorial.html#running-the-host-and-client","text":"You will need Linux to test your enclave. Just run the host app like any app - no special startup scripts or setup is required with Conclave! 1 2 3 cd host/build/distributions tar xvf host.tar ./host/bin/host If your Linux machine doesn't have SGX, you should see something like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 This platform does not support hardware enclaves: SGX_DISABLED_UNSUPPORTED_CPU: SGX is not supported by the CPU in this system This attestation requires 2163 bytes. Remote attestation for enclave F86798C4B12BE12073B87C3F57E66BCE7A541EE3D0DDA4FE8853471139C9393F: - Mode: SIMULATION - Code signing key hash: 01280A6F7EAC8799C5CFDB1F11FF34BC9AE9A5BC7A7F7F54C77475F445897E3B - Public signing key: 302A300506032B65700321000568034F335BE25386FD405A5997C25F49508AA173E0B413113F9A80C9BBF542 - Public encryption key: A0227D6D11078AAB73407D76DB9135C0D43A22BEACB0027D166937C18C5A7973 - Product ID: 1 - Revocation level: 0 Assessed security level at 2020-07-17T16:31:51.894697Z is INSECURE - Enclave is running in simulation mode. Reversing Hello World!: !dlrow olleH Listening on port 9999. Use the client app to send strings for reversal. The host has loaded the enclave, obtained its remote attestation (the EnclaveInstanceInfo object), printed it out, asked the enclave to reverse a string and finally opened up a TCP port which will now listen for requests from remote clients. So, let's run the client app: 1 ./gradlew client:run --args = \"reverse me!\" The client will connect to the host, download the EnclaveInstanceInfo , check it, and then send an encrypted string to reverse. The host will deliver this encrypted string to the enclave, and the enclave will send back to the client the encrypted reversed response: 1 2 3 4 Reading a remote attestation of length 2163 bytes. Sending the encrypted mail to the host. Reading reply mail of length 196 bytes. Enclave reversed 'reverse me!' and gave us the answer '!em esrever' Try this: 1 ./gradlew client:run --args = \"aibohphobia\" Tip Aibohphobia is the fear of palindromes.","title":"Running the host and client"},{"location":"tutorial.html#testing-on-windows-and-macos","text":"The easiest way to test your code is always to use the mock environment. This runs everything inside the host JVM and thus gives high performance, cross platform portability and full debugging support, as all the SGX infrastructure is kept out of the way. However, it means you aren't testing on the same JVM that will be used in the enclave. To create and run a real enclave on Windows or macOS you will need to run the host on a Linux virtual machine with a simulation mode enclave. The easiest way to do this is to use Docker, which is integrated with Conclave and hides the virtual machine setup from you. Install Docker and then follow these instructions. Tip If you are using the avian runtime then you may need to run this command in the root of your Gradle project first: gradlew setupLinuxExecEnvironment . You don't need to do this if you use the graalvm_native_image runtime. The following command creates a temporary Docker container that mounts the current directory then runs the host within the container. The container is automatically stopped and removed after the host exits. The host may use port 8080 for networking. Note that this command should be run from the root of your Gradle project, assuming your host program is in a module called host - adjust the paths if not. Windows PowerShell 1 docker run -t --rm -p 8080:8080 -v ${ PWD } :/project -w /project conclave-build ./host/build/install/host/bin/host macOS Terminal 1 docker run -t -p 8080:8080 --rm -v $PWD:/project -w /project --user $(id -u):$(id -g) conclave-build ./host/build/install/host/bin/host You may want to create an IntelliJ launch configuration to automatically rebuild the host and enclave (if needed) before running the host in the container. Put the command above in a .cmd batch file (Windows) or a .sh file (macOS) and then use the \"Shell script\" launch configuration type, and add a Gradle task in the \"Before launch\" section. You should make it depend on the host's installDist target. You will then be able to click the run icon in your IDE to build and start up the Java host app inside the Docker container. If on macOS and on a version of IntelliJ before 2020.3 you can set the default interpreter to exec - this will make IntelliJ complain when you try to save or run it, but if you bypass those warnings it will cause the terminal tab to close when the host exits, which keeps your terminal area clean. Versions of IntelliJ after 2020.3 don't need this as they provide a check box to control whether the host will be in a Run tab or a terminal tab. If you get stuck please contact conclave-discuss@groups.io and ask for help!","title":"Testing on Windows and macOS"},{"location":"writing-hello-world.html","text":"Writing the sample enclave \u00b6 The sample \"hello world\" enclave just reverses whatever string is passed into it. We'll do these things to make our own version of the hello enclave project: Configure Gradle. At this time Conclave projects must use Gradle as their build system. Implement an enclave object that accepts both local calls from the host, and encrypted messages from a client. Write the host program that loads the enclave. Run the host and enclave in simulation and debug modes. Write the client that sends the enclave encrypted messages via the host. Configure your modules \u00b6 Create a new Gradle project via whatever mechanism you prefer, e.g. IntelliJ can do this via the New Project wizard. Create three modules defined in the project: one for the host, one for the enclave and one for the client. The host program may be an existing server program of some kind, e.g. a web server, but in this tutorial we'll write a command line host. The client may likewise be a GUI app or integrated with some other program (like a server), but in this case to keep it simple the client will also be a command line app. Root settings.gradle file \u00b6 In the unzipped SDK there is a directory called repo that contains a local Maven repository. This is where the libraries and Gradle plugin can be found. We need to tell Gradle to look there for plugins. Create or modify a file called settings.gradle in your project root directory so it looks like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 pluginManagement { repositories { maven { def repoPath = file ( rootDir . relativePath ( file ( conclaveRepo ))) if ( repoPath == null ) throw new Exception ( \"Make sure the 'conclaveRepo' setting exists in gradle.properties, or your \\$HOME/gradle.properties file. See the Conclave tutorial on https://docs.conclave.net\" ) else if (! new File ( repoPath , \"com\" ). isDirectory ()) throw new Exception ( \"The $repoPath directory doesn't seem to exist or isn't a Maven repository; it should be the SDK 'repo' subdirectory. See the Conclave tutorial on https://docs.conclave.net\" ) url = repoPath } // Add standard repositories back. gradlePluginPortal () jcenter () mavenCentral () } plugins { id 'com.r3.conclave.enclave' version conclaveVersion apply false } } include 'enclave' include 'host' This boilerplate is unfortunately necessary to copy/paste into each project that uses Conclave. It sets up Gradle to locate the plugin that configures the rest of the boilerplate build logic for you The pluginManagement block tells Gradle to use a property called conclaveRepo to find the repo directory in your SDK download. Because developers on your team could unpack the SDK anywhere, they must configure the path before the build will work. The code above will print a helpful error if they forget or get it wrong. To set the value a developer can add to the gradle.properties file a couple of lines like this: 1 2 conclaveRepo=/path/to/sdk/repo conclaveVersion=0.3 0.3 here means use beta 3. Gradle properties can be set using a file in the project directory, or more usefully in the developer's home directory. You may wish to put the version in the project's gradle.properties file and the path in each developer's personal gradle.properties . Alternatively just add a sdk directory to the .gitignore and require everyone to unpack the SDK to the source tree. Root build.gradle file \u00b6 Add the following code to your root build.gradle file to import the repository: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 plugins { id 'java' id 'idea' } idea { module { downloadJavadoc = true } } subprojects { apply plugin: 'idea' idea { module { downloadJavadoc = true } } repositories { maven { url = rootProject . file ( conclaveRepo ) } mavenCentral () } } Tip Most of this boilerplate isn't strictly necessary except for the highlighted region. However, the rest works around a bug in IntelliJ IDEA if you wish to use that IDE in which interactive JavaDocs would otherwise not be available. To benefit from the workaround you should run ./gradlew idea to generate your IntelliJ project. If IntelliJ is running at the time it should automatically notice the changes and apply them. If you click \"import from Gradle\" in the notification popup workflow then everything will work fine except JavaDoc integration. Configure the host module \u00b6 SGX enclaves can be used in one of four modes, in order of increasing realism: Mock: your enclave class is created in the host JVM and no native or SGX specific code is used. Simulation: an enclave is compiled to native and loaded, but SGX hardware doesn't need to be present. Debug: the enclave is loaded using SGX hardware and drivers, but with a back door that allows debugger access to the memory. Release: the enclave is loaded using SGX hardware and drivers, and there's no back door. This is the real deal. Only release mode locks out the host and provides the standard SGX security model. At this time it requires the enclave to be signed with a key whitelisted by Intel. Future versions of Conclave will remove this restriction for modern hardware that supports flexible launch control . Add this bit of code to your host build.gradle file to let the mode be chosen from the command line: 1 2 // Override the default (simulation) with -PenclaveMode= def mode = findProperty ( \"enclaveMode\" )?. toString ()?. toLowerCase () ?: \"simulation\" Then add the following dependencies, also to the host's build.gradle : 1 2 3 4 5 6 7 dependencies { implementation \"com.r3.conclave:conclave-host:$conclaveVersion\" runtimeOnly project ( path: \":enclave\" , configuration: mode ) runtimeOnly \"org.slf4j:slf4j-simple:1.7.30\" testImplementation \"org.junit.jupiter:junit-jupiter:5.6.0\" } This says that at runtime (but not compile time) the :enclave module must be on the classpath, and configures dependencies to respect the three different variants of the enclave. That is, the enclave module will expose tasks to compile and use either simulation, debug or release mode (in mock mode you're just using regular Java, so no special compilation is necessary). Which task to use is actually selected by the host build. For this simple tutorial we also add a runtime-only dependency on the popular SLF4J library which Conclave uses to do logging. SLF4J enables you to send Conclave's logging to any of the major logging frameworks used in Java, but here, we add the \"simple\" backend which just causes it to log to the console. Finally we configure unit testing using JUnit 5. If you intend to use an external signing process to sign your enclave then add the following lines to the Gradle file: 1 2 3 4 // Create a task that can be used for generating signing materials tasks . register ( \"prepareForSigning\" ) { it . dependsOn ( \":enclave:generateEnclaveSigningMaterial\" + mode . capitalize ()) } This creates a new task that can be invoked using Gradle to halt the build after generating materials that need to be signed by an external signing process. After the material has been signed the build can be resumed. Configure the enclave module \u00b6 Add the Conclave Gradle plugin: 1 2 3 plugins { id 'com.r3.conclave.enclave' } and a dependency on the Conclave enclave library: 1 2 3 4 5 dependencies { implementation \"com.r3.conclave:conclave-enclave\" testImplementation \"com.r3.conclave:conclave-testing\" testImplementation \"org.junit.jupiter:junit-jupiter:5.6.0\" } This time you don't have to specify the Conclave version because the plugin will set that for you automatically. Specify the enclave's runtime environment, product ID and revocation level: 1 2 3 4 5 conclave { runtime = graalvm_native_image productID = 1 revocationLevel = 0 } The runtime setting tells Conclave which runtime environment to use inside the enclave and can either be avian or graalvm_native_image . If the setting is omitted then it defaults to graalvm_native_image . See Architecture overview for details on the differences between the two supported runtime environments. The graalvm_native_image value is new and has a few limitations, but runs much faster. Conclave needs access to a Linux build environment in order to build enclaves with the graalvm_native_image runtime. On MacOS and Windows this is automatically created during the build process using Docker. If you do not have Docker installed then the build will generate an error prompting you to switch to using either the avian runtime or to install Docker on your system. Once Docker is installed and added to your PATH environment variable you can proceed to build graalvm_native_image enclaves. Docker is not required for enclaves using the avian runtime. The product ID is an arbitrary number that can be used to distinguish between different enclaves produced by the same organisation (which may for internal reasons wish to use a single signing key). This value should not change once you picked it. The revocation level should be incremented if a weakness in the enclave code discovered and fixed; doing this will enable clients to avoid connecting to old, compromised enclaves. The revocation level should not be incremented on every new release, but only when security improvements have been made. Specify the signing methods for each of the build types. You could keep your private key in a file for both debug and release enclaves if you like, but some organisations require private keys to be held in an offline system or HSM. In that case, configure it like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 conclave { productID = 1 revocationLevel = 0 // For simulation, we want to use the default signing type of dummyKey so // we do not need to specify a configuration. debug { signingType = privateKey signingKey = file ( \"../signing/sample_private_key.pem\" ) } release { // To protect our release private key with an HSM, the enclave needs to be built in stages. // Firstly, build the signing material: // ./gradlew prepareForSigning -PenclaveMode=\"Release\" // // Generate a signature from the signing material. // // Finally build the signed enclave: // ./gradlew build -PenclaveMode=\"Release\" // signingType = externalKey signatureDate = new Date ( 1970 , 0 , 1 ) mrsignerSignature = file ( \"../signing/signature.bin\" ) mrsignerPublicKey = file ( \"../signing/external_signing_public.pem\" ) } runtime = graalvm_native_image } Configure the client build \u00b6 The client build is the simplest of all. This is literally a bog-standard hello world command line app Gradle build, with a single dependency on the Conclave client library: 1 2 3 4 5 6 7 8 9 10 11 12 plugins { id 'java' id 'application' } application { mainClassName = \"com.r3.conclave.sample.client.Client\" } dependencies { implementation \"com.r3.conclave:conclave-client:$conclaveVersion\" } And with that, we're done configuring the build. Signing keys \u00b6 The example configuration above specifies different signing configurations for each of the different build types. Simulation builds use the default dummy key. Debug builds use a private key stored in a file. Release builds use a private key managed by some external signing process. The hello-world sample in the SDK contains some example keys that can be used with the privateKey and externalKey signing types. These can be found in hello-world/signing/ . Key Files Description sample_private_key.pem A 3072 bit RSA private key that can be used to test the privateKey signing type external_signing_*.pem An AES encrypted 3072 bit RSA public/private key pair that can be used to test the externalKey signing type. The private key can be accessed with the password '12345' Alternatively you can provide or generate your own keys. Important These keys aren't whitelisted by Intel so you can't use them for real release builds. Only use these sample keys for the tutorial. Don't use them for signing your own enclaves! Create a new subclass of Enclave \u00b6 Enclaves are similar to standalone programs and as such have an equivalent to a \"main class\". This class must be a subclass of Enclave . Create your enclave class: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package com.superfirm.enclave ; // CHANGE THIS import com.r3.conclave.enclave.Enclave ; /** * Simply reverses the bytes that are passed in. */ public class ReverseEnclave extends Enclave { @Override public byte [] receiveFromUntrustedHost ( byte [] bytes ) { byte [] result = new byte [ bytes . length ] ; for ( int i = 0 ; i < bytes . length ; i ++ ) result [ i ] = bytes [ bytes . length - 1 - i ] ; return result ; } } The Enclave class by itself doesn't require you to support direct communication with the host. This is because sometimes you don't need that and shouldn't have to implement message handlers. In this case we'll use that functionality because it's a good place to start learning, so we also override and implement the receiveFromUntrustedHost method which takes a byte array and optionally returns a byte array back. Here we just reverse the contents. Tip In a real app you would use the byte array to hold serialised data structures. You can use whatever data formats you like. You could use a simple string format or a binary format like protocol buffers. Write a simple host program \u00b6 An enclave by itself is just a library: you must therefore load it from inside a host program. It's easy to load then pass data to and from an enclave. Let's start with the skeleton of a little command line app: 1 2 3 4 5 6 7 8 9 10 11 12 /** * This class demonstrates how to load an enclave and use it. */ public class Host { public static void main ( String [] args ) throws EnclaveLoadException { // TODO: Fill this out } public static String callEnclave ( EnclaveHost enclave , String input ) { // TODO: Fill this out. } } At first we will be building and running our enclave in simulation mode. This does not require the platform hardware to support SGX. However simulation mode does require us to be using Linux. If we are not using Linux as our host OS then we can use a Linux container or virtual machine. Alternatively we could use mock mode instead of simulation mode. When we want to switch to loading either a debug or release build of the enclave we need to ensure the platform supports SGX. By adding the code below to the main method we can determine whether the platform can load debug and release enclaves. This method reports the actual hardware status even if you are currently working with simulation enclaves. If SGX is not supported the function throws an exception which describes the reason why. There are a number of common reasons why SGX may not be supported including: The CPU or the system BIOS does not support SGX. The host operating system is Windows or Mac OS. Conclave currently only supports loading enclaves in simulation, debug or release modes on Linux. SGX is disabled in the BIOS and must be manually enabled by the user. SGX is disabled but can be enabled in software. If SGX is disabled but can be enabled in software the code below attempts to automatically enable SGX support by specifying the 'true' parameter. It might be necessary to run this application with root access and/or reboot the system in order to successfully enable SGX. The exception message will describe if this is the case. 1 2 3 4 5 6 try { EnclaveHost . checkPlatformSupportsEnclaves ( true ); System . out . println ( \"This platform supports enclaves in simulation, debug and release mode.\" ); } catch ( EnclaveLoadException e ) { System . out . println ( \"This platform does not support hardware enclaves: \" + e . getMessage ()); } To load the enclave we'll put this after the platform check: 1 2 3 4 5 6 7 8 9 String className = \"com.r3.conclave.sample.enclave.ReverseEnclave\" ; try ( EnclaveHost enclave = EnclaveHost . load ( className )) { enclave . start ( null , null ); System . out . println ( callEnclave ( enclave , \"Hello world!\" )); // !dlrow olleH :-) // TODO: Get the remote attestation } This code starts by creating an EnclaveHost object. This names the class and then attempts to load it inside another JVM running inside an enclave. A remote attestation procedure is then performed involving Intel's servers. This procedure can fail if attempting to load a debug or release enclave and the platform does not support SGX. This is why it is important to perform the platform check we made in the code above. If the enclave does fail to load for any reason then an exception is thrown describing the reason why. We then call start which initialises the enclave and the MyEnclave class inside it. You can load multiple enclaves at once but they must all use same mode, and each enclave will get its own isolated JVM. Note that an EnclaveHost allocates memory out of a pool called the \"enclave page cache\" which is a machine-wide limited resource. It'll be freed if the host JVM quits, but it's good practice to close the EnclaveHost object by calling close on it when done. Therefore we also make sure the .close() method is called on the enclave no matter what using a try-with-resources statement. This doesn't actually matter in such a tiny hello world sample, because the enclave will be unloaded by the kernel once we exit like any other resource. It's just here to remind you that an enclave must be explicitly unloaded if you need to reinitialise it for whatever reason, or if you need the memory back. Warning Starting and stopping/closing an enclave is not free, so don't load the enclave, use it and immediately close it again as in the above example. Cost-wise it's like starting a regular process even though no process will actually exist. Treat the enclave like any other expensive resource and keep it around for as long as you might need it. Once we started the enclave, we call it passing in a string as bytes. The enclave will reverse it and we'll print out the answer. This is as easy as calling EnclaveHost.callEnclave , so put this in the callEnclave static method defined above: 1 2 // We'll convert strings to bytes and back. return new String ( enclave . callEnclave ( input . getBytes ())); So we just convert the string to bytes, send it to the enclave, and convert the response from bytes back to a string. Remote attestation \u00b6 There's no point in using an enclave to protect purely local data, as the data must ultimately come from the (assumed malicious/compromised) host in that scenario. That's why you need remote attestation, which lets an enclave prove its identity to the third parties who will upload secret data. If this paragraph doesn't make sense please review the Architecture overview and the enclaves section. Before we can set up communication with a client, we must therefore get remote attestation working. Using remote attestation is easy! Just obtain an EnclaveInstanceInfo and serialize/deserialize it using the provided methods. There's a useful toString method: 1 2 3 final EnclaveInstanceInfo attestation = enclave . getEnclaveInstanceInfo (); final byte [] attestationBytes = attestation . serialize (); System . out . println ( EnclaveInstanceInfo . deserialize ( attestationBytes )); That will print out something like this: 1 2 3 4 5 6 7 8 9 10 Remote attestation for enclave F86798C4B12BE12073B87C3F57E66BCE7A541EE3D0DDA4FE8853471139C9393F: - Mode: SIMULATION - Code signing key hash: 01280A6F7EAC8799C5CFDB1F11FF34BC9AE9A5BC7A7F7F54C77475F445897E3B - Public signing key: 302A300506032B65700321000568034F335BE25386FD405A5997C25F49508AA173E0B413113F9A80C9BBF542 - Public encryption key: A0227D6D11078AAB73407D76DB9135C0D43A22BEACB0027D166937C18C5A7973 - Product ID: 1 - Revocation level: 0 Assessed security level at 2020-07-17T16:31:51.894697Z is INSECURE - Enclave is running in simulation mode. The hash in the first line is the measurement . This is a hash of the code of the enclave. It includes both all the Java code inside the enclave as a fat-JAR, and all the support and JVM runtime code required. As such it will change any time you alter the code of your enclave, the version of Conclave in use or the mode (simulation/debug/release) of the enclave. The enclave measurement should be stable across builds and machines, so clients can audit the enclave by repeating the Gradle build and comparing the value they get in the EnclaveInstanceInfo against what the build process prints out. Tip All this data is available via individual getters on the EnclaveInstanceInfo so you should never feel a need to parse the output of toString . EnclaveInstanceInfo is an interface so you can easily build mock attestations in your tests. When not in simulation mode the timestamp is signed by Intel and comes from their servers. An instance has a security assessment, which can change in response to discovery of vulnerabilities in the infrastructure (i.e. without anything changing about the host or enclave itself). As we can see this enclave isn't actually considered secure yet because we're running in simulation mode still. An enclave can be SECURE , STALE , or INSECURE . A assessment of STALE means there is a software/firmware/microcode update available for the platform that improves security in some way. The client may wish to observe when this starts being reported and define a time span in which the remote enclave operator must upgrade. Now get the serialized bytes to a client via whatever network mechanism you want. The bytes are essentially a large, complex digital signature, so it's safe to publish them publicly. An attestation doesn't inherently expire but because the SGX ecosystem is always moving, client code will typically have some frequency with which it expects the host code to refresh the EnclaveInstanceInfo . At present this is done by stopping/closing and then restarting the enclave. Configurating attestation \u00b6 To use SGX remote attestation for real we need to do some additional work. Remember how we wrote enclave.start(null, null); above? The first parameter contains configuration data required to use an attestation service. There are three kinds of attestation service: EPID. This older protocol is supported by some desktop/laptop class Intel CPUs. The EPID protocol includes some consumer privacy cryptography, and involves talking directly to Intel's IAS service to generate an attestation. For that you need to obtain an API key and service provider ID from Intel. You can sign-up easily and for free. Learn more about IAS . Azure DCAP. The datacenter attestation primitives protocol is newer and designed for servers. When running on a Microsoft Azure Confidential Compute VM or Kubernetes pod, you don't need any parameters. It's all configured out of the box. Generic DCAP. When not running on Azure, you need to obtain API keys for Intel's PCCS service. We'll target Azure for now to keep things simple. Replace the call to EnclaveHost.start above with this snippet: 1 enclave . start ( new AttestationParameters . DCAP (), null ); Info Why does Conclave need to contact Intel's servers? It's because those servers contain the most up to date information about what CPUs and system enclave versions are considered secure. Over time these servers will change their assessment of the host system and this will be visible in the responses, as security improvements are made. Run what we've got so far \u00b6 We can apply the Gradle application plugin and set the mainClassName property in the usual manner to let us run the host from the command line. Now run gradlew host:run and it should print \"Hello World!\" backwards along with the security info as shown above. During the build you should see output like this: 1 2 3 > Task :enclave:generateEnclaveletMetadataSimulation Succeed. Enclave measurement: 04EDA32215B496C3890348752F47D77DC34989FE4ECACCF5EC5C054F1D68BBE6 The measurement should correspond to the value found in the EnclaveInstanceInfo.getCodeHash() property. You can switch to debug mode by specifying the enclaveMode property. In debug mode the real hardware is used and virtually everything is identical to how it will be in production, but there's a small back door that can be used by debuggers to read/write the enclave's memory. You will need to run this on an Azure Confidential VM . gradlew -PenclaveMode=debug host:run Encrypted messaging \u00b6 The enclave isn't of much use to the host, because the host already trusts itself. It's only useful to remote clients that want to use the enclave for computation without having to trust the host machine or software. We're now going to wire up encrypted messaging. Conclave provides an API for this called Mail. Conclave Mail handles all the encryption for you, but leaves it up to you how the bytes themselves are moved around. You could use a REST API, a gRPC API, JMS message queues, a simple TCP socket as in this tutorial, or even files. Info Learn more about the design of Conclave Mail , and compare it to TLS . Receiving and posting mail in the enclave \u00b6 Firstly we need to upgrade our little enclave to be able to receive mails from clients. This is easy! Just override the receiveMail method: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /** * Simply reverses the bytes that are passed in. */ public class ReverseEnclave extends Enclave { @Override public byte [] receiveFromUntrustedHost ( byte [] bytes ) { byte [] result = new byte [ bytes . length ] ; for ( int i = 0 ; i < bytes . length ; i ++ ) { result [ i ] = bytes [ bytes . length - 1 - i ] ; } return result ; } @Override protected void receiveMail ( long id , EnclaveMail mail ) { byte [] reversed = receiveFromUntrustedHost ( mail . getBodyAsBytes ()); MutableMail reply = createMail ( mail . getAuthenticatedSender (), reversed ); postMail ( reply , null ); } } The receiveFromUntrustedHost method here isn't really needed, it's just because we're already using this to demonstrate local calls. The new part is receiveMail . This method takes two parameters: an identifier that the host gets to pick, which doesn't mean anything but we can use to acknowledge the mail if we want to using Enclave.acknowledgeMail . Acknowledgement can be used to tell the host the enclave is done processing the mail if it doesn't want to reply immediately. It will be discussed more in future tutorials. In this simple tutorial we reply immediately so don't need to use this feature, and thus we ignore the ID. The second parameter is an EnclaveMail . This object gives us access to the body bytes that the client sent, but it also exposes some other header fields: The authenticated sender public key . This is the public key of the client that sent the mail. It's called \"authenticated\" because the encryption used by Conclave means you can trust that the mail was encrypted by an entity holding the private key matching this public key. If your enclave recognises the public key this feature can be used as a form of user authentication. A topic . This can be used to distinguish between different streams of mail from the same client. It's a string and can be thought of as equivalent to a URL path or port number. The from field . This is a string that the sender can pick to identify itself. Unlike the authenticated sender key this is entirely arbitrary, and nothing stops a sender picking any value it likes. Often this field won't be used. It's intended to hold some sort of routing address where the sender would like to receive replies - sometimes this is implied, but an explicit routing address can be useful when implementing more complex hosts and enclave that may not reply straight away. The envelope . This is a slot that can hold any arbitrary byte array the sender likes. It's a holding zone for app specific data that should be authenticated but unencrypted. The sequence number . This must increment by one for every mail delivered on a topic. Conclave will automatically reject messages for which this doesn't hold true, within the scope of messages seen whilst the enclave is loaded. These header fields are available to the host and therefore should not contain secrets . It may seem odd to have data that's unencrypted, but it's often useful for the client, host and enclave to collaborate in various ways related to storage and routing of data. Even when the host is untrusted it may still be useful for the client to send data that is readable by the host and enclave simultaneously, but which the host cannot tamper with. Inside the enclave you can be assured that the header fields contain the values set by the client, because they're checked before receiveMail is invoked. In this simple tutorial we only care about the body and sender public key. We reverse the bytes in the mail body and then create a response mail that will be encrypted to the sender. It contains the reversed bytes. We use the createMail method to do this. It gives us back a MutableMail object, which is a builder with setters we can use to control the sequence number, topic and so on. Once we've done configuring it to our liking we pass it to postMail which performs the encryption and delivers the newly encrypted mail to the host. It will emerge in a callback we're about to configure. Tip You can post mail anytime and to anyone you like. It doesn't have to be a response to the sender, you can post multiple mails at once and you can post mails inside receiveFromUntrustedHost (i.e. during a local call). Receiving and posting mail in the host \u00b6 Mail posted by an enclave appears in a callback we pass to EnclaveHost.start . Let's use a really simple implementation: we'll just store the encrypted bytes in a variable, so we can pick it up later: 1 2 3 4 5 6 7 8 // Start it up. AtomicReference < byte []> mailToSend = new AtomicReference <> (); enclave . start ( attestationParameters , new EnclaveHost . MailCallbacks () { @Override public void postMail ( byte [] encryptedBytes , String routingHint ) { mailToSend . set ( encryptedBytes ); } }); Java doesn't let us directly change variables from a callback, so we use an AtomicReference here as a box. Tip Kotlin lets you alter mutable variables from callbacks directly, without needing this sort of trick. The enclave can provide a routing hint to tell the host where it'd like the message delivered. For example, this could be set to the value of the from header. It's called a \"hint\" because the enclave must always remember that the host is untrusted. It can be arbitrarily malicious and could, for example, not deliver the mail at all, or it could deliver it to the wrong place. However if it does deliver it wrongly, the encryption will ensure the bogus recipient can't do anything with the mail. In this simple hello world tutorial we can only handle one client at once so we're going to ignore the routing hint here. In a more sophisticated server you could provide an implementation of EnclaveHost.MailCallbacks that has access to your connected clients, a database, a durable queue, a ThreadLocal containing a servlet connection and so on. At the bottom of our main method let's add some code to accept TCP connections and send the EnclaveInstanceInfo to whomever connects. Then we'll accept a mail uploaded by the client, send it to the enclave, and deliver the response back. We'll write the client code in a moment. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 int port = 9999 ; System . out . println ( \"Listening on port \" + port + \". Use the client app to send strings for reversal.\" ); ServerSocket acceptor = new ServerSocket ( port ); Socket connection = acceptor . accept (); // Just send the attestation straight to whoever connects. It's signed so that's MITM-safe. DataOutputStream output = new DataOutputStream ( connection . getOutputStream ()); output . writeInt ( attestationBytes . length ); output . write ( attestationBytes ); // Now read some mail from the client. DataInputStream input = new DataInputStream ( connection . getInputStream ()); byte [] mailBytes = new byte [ input . readInt () ] ; input . readFully ( mailBytes ); // Deliver it. The enclave will give us some mail to reply with via the callback we passed in // to the start() method. enclave . deliverMail ( 1 , mailBytes , \"routingHint\" ); byte [] toSend = mailToSend . getAndSet ( null ); output . writeInt ( toSend . length ); output . write ( toSend ); This code is straightforward. In order, it: Opens a socket using the Java sockets API and listens for a connection. Accepts a connection and then sends the serialized EnclaveInstanceInfo to the client. We first send the length so the client knows how many bytes to read. The client will send us a byte array back, which contains an encrypted string. This code can't read the body, it's just encrypted bytes except for a few fields in the headers, which are available to the host. We deliver the encrypted mail bytes to the enclave. We pick up the response from the AtomicReference box that was set by the callback. The first parameter to deliverMail is a \"mail ID\" that the enclave can use to identify this mail to the host. This feature is intended for use with acknowledgement, which allows the enclave to signal that it's done with that message and the work it represents can be atomically/transactionally completed. The routing hint is an arbitrary string that can be used to identify the sender of the mail from the host's perspective, e.g. a connection ID, username, identity - it's up to you. The enclave can use this string to signal to the host that a mail should go to that location. It's called a \"hint\" to remind you that the host code may be modified or writter by an attacker, so the enclave can't trust it. However, the encryption on the mail makes it useless for the host to mis-direct mail. Todo In future we will provide APIs to bind enclaves to common transports, to avoid this sort of boilerplate. Writing the client \u00b6 The client app will do three things: Connect to the host server and download the EnclaveInstanceInfo from it. Verify the enclave is acceptable: i.e. that it will do what's expected. Send it the command line arguments as a string to reverse and get back the answer, using encrypted mail. Here's the initial boilerplate to grab the user input, connect, download and deserialize the EnclaveInstanceInfo . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Client { public static void main ( String [] args ) throws IOException , InvalidEnclaveException { if ( args . length == 0 ) { System . err . println ( \"Please pass the string to reverse on the command line\" ); return ; } String toReverse = String . join ( \" \" , args ); // Connect to the host, it will send us a remote attestation (EnclaveInstanceInfo). Socket socket = new Socket ( \"localhost\" , 9999 ); DataInputStream fromHost = new DataInputStream ( socket . getInputStream ()); byte [] attestationBytes = new byte [ fromHost . readInt () ] ; fromHost . readFully ( attestationBytes ); EnclaveInstanceInfo attestation = EnclaveInstanceInfo . deserialize ( attestationBytes ); } } Constraints \u00b6 How do you know the EnclaveInstanceInfo you've got is for the enclave you really intend to interact with? In normal client/server programming you connect to a host using some sort of identity, like a domain name or IP address. TLS is used to ensure the server that picks up is the rightful owner of the domain name you intended to connect to. In enclave programming the location of the enclave might not matter much because the host is untrusted. Instead you have to verify what is running, rather than where it's running. Note The domain name of the server can still be important in some applications, in which case you should use TLS instead of raw sockets as is the case here. One way to do this is by inspecting the properties on the EnclaveInstanceInfo object and hard-coding some logic. That works fine, but testing an EnclaveInstanceInfo is a common pattern in enclave programming, so we provide an API to do it for you. The EnclaveConstraint class takes an EnclaveInstanceInfo and performs some matching against it. A constraint object can be built in code, or it can be loaded from a small domain specific language encoded as a one-line string. The string form is helpful if you anticipate frequent upgrades that should be whitelisted or other frequent changes to the acceptable enclave, as it can be easily put into a configuration file, JSON, XML or command line flags. The constraint lets you specify: Acceptable code hashes (measurements) Acceptable signing public keys The minimum revocation level The product ID The security level of the instance: SECURE , STALE , INSECURE If you specify a signing public key then you must also specify the product ID, otherwise if the organisation that created the enclave makes a second different kind of enclave in future, a malicious host might connect you with the wrong one. If the input/output commands are similar then a confusion attack could be opened up. That's why you must always specify the product ID even if it's zero. The simplest possible string-form constraint looks like this: C:F86798C4B12BE12073B87C3F57E66BCE7A541EE3D0DDA4FE8853471139C9393F It says \"accept exactly one program, with that measurement hash\". In this case the value came from the output of the build process as shown above. This is useful when you don't trust the author nor host of the enclave, and want to audit the source code and then reproduce the build. Often that's too rigid. We trust the developer of the enclave, just not the host. In that case we'll accept any enclave signed by the developer's public key. We can express that by listing code signing key hashes, like this: S:01280A6F7EAC8799C5CFDB1F11FF34BC9AE9A5BC7A7F7F54C77475F445897E3B PROD:1 When constraining to a signing key we must also specify the product ID, because a key can be used to sign more than one product. 1 2 3 // Check it's the enclave we expect. This will throw InvalidEnclaveException if not valid. // The hash here comes from observing what the build printed. EnclaveConstraint . parse ( \"S:01280A6F7EAC8799C5CFDB1F11FF34BC9AE9A5BC7A7F7F54C77475F445897E3B PROD:1 SEC:INSECURE\" ). check ( attestation ); This line of code parses a simple constraint that says any enclave (even if run in simulation mode) signed by this hash of a code signing key with product ID of 1 is acceptable. Obviously in a real app, you would remove the part that says SEC:INSECURE , but it's convenient to have this whilst developing. You'd probably also retrieve the constraint from a configuration file, system property or command line flag. Finally it uses the check method with the attestation object. If anything is amiss an exception is thrown, so past this point we know we're talking to the real ReverseEnclave we wrote earlier. Keys and mail \u00b6 We want to receive a response from the enclave, and we want that to be encrypted/tamperproofed too. That means we need a key pair of our own. Conclave uses Curve25519, a state of the art elliptic curve algorithm. For reasons of implementation robustness and avoidance of side channel attacks, this is the only algorithm supported by Conclave Mail. If you want to use other algorithms for some reason you would need to implement your own messaging system on top of host-local calls. Alternatively, use that other algorithm to encrypt/decrypt a Curve25519 private key. Generating such a key is straightforward: 1 KeyPair myKey = new Curve25519KeyPairGenerator (). generateKeyPair (); Unfortunately the Java Cryptography Architecture only introduced official support for Curve25519 in Java 11. At the moment in Conclave therefore, you must utilize our Curve25519KeyPairGenerator , Curve25519PublicKey and Curve25519PrivateKey classes. In future we may offer support for using the Java 11 JCA types directly. A Curve25519 private key is simply 32 random bytes, which you can access using the getEncoded() method on PrivateKey . Now we have a key with which to receive the response, we create a mail to the enclave. This is done using the EnclaveInstanceInfo.createMail method, which returns a MutableMail object. We must set our private key on the mail so it's mixed in to the calculations when the mail is encrypted and thus becomes available in getAuthenticatedSender() inside the enclave: without the call to setPrivateKey the authenticated sender will be null. This can sometimes be appropriate, if for example, the enclave already knows the sender's private key via some other mechanism. The sequence number for this newly created mail is zero. That means if we re-run the program twice we'll try to send the enclave two mails with the same topic, sender and sequence number. This is invalid: the enclave will reject it as an apparent replay attack until it's restarted and forgets what mail it received. We could keep a counter on disk and increment it, but it's easier to simply set the topic to a random UUID. After that, we can encrypt the mail. 1 2 3 4 5 MutableMail mail = attestation . createMail ( toReverse . getBytes ( StandardCharsets . UTF_8 )); mail . setPrivateKey ( myKey . getPrivate ()); // Set a random topic, so we can re-run this program against the same server. mail . setTopic ( UUID . randomUUID (). toString ()); byte [] encryptedMail = mail . encrypt (); In more complex apps it might be smart to use the topic in more complex ways, like how a web app can use the URL to separate different functions of the app. Now we have an encrypted message we can write it to the socket and receive the enclave's response. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 System . out . println ( \"Sending the encrypted mail to the host.\" ); DataOutputStream toHost = new DataOutputStream ( socket . getOutputStream ()); toHost . writeInt ( encryptedMail . length ); toHost . write ( encryptedMail ); // Enclave will mail us back. byte [] encryptedReply = new byte [ fromHost . readInt () ] ; System . out . println ( \"Reading reply mail of length \" + encryptedReply . length + \" bytes.\" ); fromHost . readFully ( encryptedReply ); // Decrypt the reply EnclaveMail reply = attestation . decryptMail ( encryptedReply , myKey . getPrivate ()); System . out . println ( \"Enclave reversed '\" + toReverse + \"' and gave us the answer '\" + new String ( reply . getBodyAsBytes ()) + \"'\" ); socket . close (); We write out the length of the mail, then the mail bytes, then read the length of the response and read the response bytes. Finally we use EnclaveInstanceInfo.decryptMail , passing in the encrypted reply we got and our own private key. This method checks the bytes really did come from that enclave (by checking the authenticated sender key against the enclave's public key in the attestation), decodes the bytes and yields the reply. We can then access the body of the message using EnclaveMail.getBodyAsBytes() . Finally we close the socket, and we're done. Phew! \ud83d\ude05 Testing \u00b6 There are two ways you can test the enclave: as a mock or natively. Mock \u00b6 The conclave-testing library has a MockHost class which lets you whitebox test your enclave by running the enclave fully in-memory. There is no need for SGX hardware or a specific OS and thus ideal for cross-platform unit testing. The underlying enclave object is also exposed enabling you to make assertions on the enclave's state, something that cannot be done on real hardware or even in simulation mode. In your enclave module add the following test dependency 1 testImplementation \"com.r3.conclave:conclave-testing\" You create your mock enclave by calling MockHost.loadMock . 1 2 3 MockHost < ReverseEnclave > mockHost = MockHost . loadMock ( ReverseEnclave . class ); mockHost . start ( null , null , null ); ReverseEnclave reverseEnclave = mockHost . getEnclave (); MockHost is a EnclaveHost so you call the enclave as normal with callEnclave . You have direct assess to the enclave object instance with mockHost.getEnclave() . Native \u00b6 Testing the enclave natively is relatively straightforward: the enclave needs to be loaded with EnclaveHost.load . By default this will run the tests in a simulated environment and will require the correct OS. Native tests are ideal for integration testing. To test the enclave in debug mode on real secure hardware the -PenclaveMode=debug flag needs to be specified and the SPID and attestation key need to be passed into the test. This can be done with system properties. In your host module build file: 1 2 3 4 5 test { useJUnitPlatform () // Pass through any -Pspid and -Pattestation-key parameters to the tests systemProperties project . properties . subMap ([ \"spid\" , \"attestation-key\" ]) } Pass these values to EnclaveHost.start in your test: 1 2 3 4 5 6 7 private static EnclaveHost enclave ; @BeforeAll static void startup () throws EnclaveLoadException { enclave = EnclaveHost . load ( \"com.r3.conclave.sample.enclave.ReverseEnclave\" ); enclave . start ( new AttestationParameters . DCAP (), null ); } gradlew -PenclaveMode=debug host:test Note that native tests are located in the host module while mock tests in the enclave module.","title":"Writing hello world"},{"location":"writing-hello-world.html#writing-the-sample-enclave","text":"The sample \"hello world\" enclave just reverses whatever string is passed into it. We'll do these things to make our own version of the hello enclave project: Configure Gradle. At this time Conclave projects must use Gradle as their build system. Implement an enclave object that accepts both local calls from the host, and encrypted messages from a client. Write the host program that loads the enclave. Run the host and enclave in simulation and debug modes. Write the client that sends the enclave encrypted messages via the host.","title":"Writing the sample enclave"},{"location":"writing-hello-world.html#configure-your-modules","text":"Create a new Gradle project via whatever mechanism you prefer, e.g. IntelliJ can do this via the New Project wizard. Create three modules defined in the project: one for the host, one for the enclave and one for the client. The host program may be an existing server program of some kind, e.g. a web server, but in this tutorial we'll write a command line host. The client may likewise be a GUI app or integrated with some other program (like a server), but in this case to keep it simple the client will also be a command line app.","title":"Configure your modules"},{"location":"writing-hello-world.html#root-settingsgradle-file","text":"In the unzipped SDK there is a directory called repo that contains a local Maven repository. This is where the libraries and Gradle plugin can be found. We need to tell Gradle to look there for plugins. Create or modify a file called settings.gradle in your project root directory so it looks like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 pluginManagement { repositories { maven { def repoPath = file ( rootDir . relativePath ( file ( conclaveRepo ))) if ( repoPath == null ) throw new Exception ( \"Make sure the 'conclaveRepo' setting exists in gradle.properties, or your \\$HOME/gradle.properties file. See the Conclave tutorial on https://docs.conclave.net\" ) else if (! new File ( repoPath , \"com\" ). isDirectory ()) throw new Exception ( \"The $repoPath directory doesn't seem to exist or isn't a Maven repository; it should be the SDK 'repo' subdirectory. See the Conclave tutorial on https://docs.conclave.net\" ) url = repoPath } // Add standard repositories back. gradlePluginPortal () jcenter () mavenCentral () } plugins { id 'com.r3.conclave.enclave' version conclaveVersion apply false } } include 'enclave' include 'host' This boilerplate is unfortunately necessary to copy/paste into each project that uses Conclave. It sets up Gradle to locate the plugin that configures the rest of the boilerplate build logic for you The pluginManagement block tells Gradle to use a property called conclaveRepo to find the repo directory in your SDK download. Because developers on your team could unpack the SDK anywhere, they must configure the path before the build will work. The code above will print a helpful error if they forget or get it wrong. To set the value a developer can add to the gradle.properties file a couple of lines like this: 1 2 conclaveRepo=/path/to/sdk/repo conclaveVersion=0.3 0.3 here means use beta 3. Gradle properties can be set using a file in the project directory, or more usefully in the developer's home directory. You may wish to put the version in the project's gradle.properties file and the path in each developer's personal gradle.properties . Alternatively just add a sdk directory to the .gitignore and require everyone to unpack the SDK to the source tree.","title":"Root settings.gradle file"},{"location":"writing-hello-world.html#root-buildgradle-file","text":"Add the following code to your root build.gradle file to import the repository: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 plugins { id 'java' id 'idea' } idea { module { downloadJavadoc = true } } subprojects { apply plugin: 'idea' idea { module { downloadJavadoc = true } } repositories { maven { url = rootProject . file ( conclaveRepo ) } mavenCentral () } } Tip Most of this boilerplate isn't strictly necessary except for the highlighted region. However, the rest works around a bug in IntelliJ IDEA if you wish to use that IDE in which interactive JavaDocs would otherwise not be available. To benefit from the workaround you should run ./gradlew idea to generate your IntelliJ project. If IntelliJ is running at the time it should automatically notice the changes and apply them. If you click \"import from Gradle\" in the notification popup workflow then everything will work fine except JavaDoc integration.","title":"Root build.gradle file"},{"location":"writing-hello-world.html#configure-the-host-module","text":"SGX enclaves can be used in one of four modes, in order of increasing realism: Mock: your enclave class is created in the host JVM and no native or SGX specific code is used. Simulation: an enclave is compiled to native and loaded, but SGX hardware doesn't need to be present. Debug: the enclave is loaded using SGX hardware and drivers, but with a back door that allows debugger access to the memory. Release: the enclave is loaded using SGX hardware and drivers, and there's no back door. This is the real deal. Only release mode locks out the host and provides the standard SGX security model. At this time it requires the enclave to be signed with a key whitelisted by Intel. Future versions of Conclave will remove this restriction for modern hardware that supports flexible launch control . Add this bit of code to your host build.gradle file to let the mode be chosen from the command line: 1 2 // Override the default (simulation) with -PenclaveMode= def mode = findProperty ( \"enclaveMode\" )?. toString ()?. toLowerCase () ?: \"simulation\" Then add the following dependencies, also to the host's build.gradle : 1 2 3 4 5 6 7 dependencies { implementation \"com.r3.conclave:conclave-host:$conclaveVersion\" runtimeOnly project ( path: \":enclave\" , configuration: mode ) runtimeOnly \"org.slf4j:slf4j-simple:1.7.30\" testImplementation \"org.junit.jupiter:junit-jupiter:5.6.0\" } This says that at runtime (but not compile time) the :enclave module must be on the classpath, and configures dependencies to respect the three different variants of the enclave. That is, the enclave module will expose tasks to compile and use either simulation, debug or release mode (in mock mode you're just using regular Java, so no special compilation is necessary). Which task to use is actually selected by the host build. For this simple tutorial we also add a runtime-only dependency on the popular SLF4J library which Conclave uses to do logging. SLF4J enables you to send Conclave's logging to any of the major logging frameworks used in Java, but here, we add the \"simple\" backend which just causes it to log to the console. Finally we configure unit testing using JUnit 5. If you intend to use an external signing process to sign your enclave then add the following lines to the Gradle file: 1 2 3 4 // Create a task that can be used for generating signing materials tasks . register ( \"prepareForSigning\" ) { it . dependsOn ( \":enclave:generateEnclaveSigningMaterial\" + mode . capitalize ()) } This creates a new task that can be invoked using Gradle to halt the build after generating materials that need to be signed by an external signing process. After the material has been signed the build can be resumed.","title":"Configure the host module"},{"location":"writing-hello-world.html#configure-the-enclave-module","text":"Add the Conclave Gradle plugin: 1 2 3 plugins { id 'com.r3.conclave.enclave' } and a dependency on the Conclave enclave library: 1 2 3 4 5 dependencies { implementation \"com.r3.conclave:conclave-enclave\" testImplementation \"com.r3.conclave:conclave-testing\" testImplementation \"org.junit.jupiter:junit-jupiter:5.6.0\" } This time you don't have to specify the Conclave version because the plugin will set that for you automatically. Specify the enclave's runtime environment, product ID and revocation level: 1 2 3 4 5 conclave { runtime = graalvm_native_image productID = 1 revocationLevel = 0 } The runtime setting tells Conclave which runtime environment to use inside the enclave and can either be avian or graalvm_native_image . If the setting is omitted then it defaults to graalvm_native_image . See Architecture overview for details on the differences between the two supported runtime environments. The graalvm_native_image value is new and has a few limitations, but runs much faster. Conclave needs access to a Linux build environment in order to build enclaves with the graalvm_native_image runtime. On MacOS and Windows this is automatically created during the build process using Docker. If you do not have Docker installed then the build will generate an error prompting you to switch to using either the avian runtime or to install Docker on your system. Once Docker is installed and added to your PATH environment variable you can proceed to build graalvm_native_image enclaves. Docker is not required for enclaves using the avian runtime. The product ID is an arbitrary number that can be used to distinguish between different enclaves produced by the same organisation (which may for internal reasons wish to use a single signing key). This value should not change once you picked it. The revocation level should be incremented if a weakness in the enclave code discovered and fixed; doing this will enable clients to avoid connecting to old, compromised enclaves. The revocation level should not be incremented on every new release, but only when security improvements have been made. Specify the signing methods for each of the build types. You could keep your private key in a file for both debug and release enclaves if you like, but some organisations require private keys to be held in an offline system or HSM. In that case, configure it like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 conclave { productID = 1 revocationLevel = 0 // For simulation, we want to use the default signing type of dummyKey so // we do not need to specify a configuration. debug { signingType = privateKey signingKey = file ( \"../signing/sample_private_key.pem\" ) } release { // To protect our release private key with an HSM, the enclave needs to be built in stages. // Firstly, build the signing material: // ./gradlew prepareForSigning -PenclaveMode=\"Release\" // // Generate a signature from the signing material. // // Finally build the signed enclave: // ./gradlew build -PenclaveMode=\"Release\" // signingType = externalKey signatureDate = new Date ( 1970 , 0 , 1 ) mrsignerSignature = file ( \"../signing/signature.bin\" ) mrsignerPublicKey = file ( \"../signing/external_signing_public.pem\" ) } runtime = graalvm_native_image }","title":"Configure the enclave module"},{"location":"writing-hello-world.html#configure-the-client-build","text":"The client build is the simplest of all. This is literally a bog-standard hello world command line app Gradle build, with a single dependency on the Conclave client library: 1 2 3 4 5 6 7 8 9 10 11 12 plugins { id 'java' id 'application' } application { mainClassName = \"com.r3.conclave.sample.client.Client\" } dependencies { implementation \"com.r3.conclave:conclave-client:$conclaveVersion\" } And with that, we're done configuring the build.","title":"Configure the client build"},{"location":"writing-hello-world.html#signing-keys","text":"The example configuration above specifies different signing configurations for each of the different build types. Simulation builds use the default dummy key. Debug builds use a private key stored in a file. Release builds use a private key managed by some external signing process. The hello-world sample in the SDK contains some example keys that can be used with the privateKey and externalKey signing types. These can be found in hello-world/signing/ . Key Files Description sample_private_key.pem A 3072 bit RSA private key that can be used to test the privateKey signing type external_signing_*.pem An AES encrypted 3072 bit RSA public/private key pair that can be used to test the externalKey signing type. The private key can be accessed with the password '12345' Alternatively you can provide or generate your own keys. Important These keys aren't whitelisted by Intel so you can't use them for real release builds. Only use these sample keys for the tutorial. Don't use them for signing your own enclaves!","title":"Signing keys"},{"location":"writing-hello-world.html#create-a-new-subclass-of-enclave","text":"Enclaves are similar to standalone programs and as such have an equivalent to a \"main class\". This class must be a subclass of Enclave . Create your enclave class: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package com.superfirm.enclave ; // CHANGE THIS import com.r3.conclave.enclave.Enclave ; /** * Simply reverses the bytes that are passed in. */ public class ReverseEnclave extends Enclave { @Override public byte [] receiveFromUntrustedHost ( byte [] bytes ) { byte [] result = new byte [ bytes . length ] ; for ( int i = 0 ; i < bytes . length ; i ++ ) result [ i ] = bytes [ bytes . length - 1 - i ] ; return result ; } } The Enclave class by itself doesn't require you to support direct communication with the host. This is because sometimes you don't need that and shouldn't have to implement message handlers. In this case we'll use that functionality because it's a good place to start learning, so we also override and implement the receiveFromUntrustedHost method which takes a byte array and optionally returns a byte array back. Here we just reverse the contents. Tip In a real app you would use the byte array to hold serialised data structures. You can use whatever data formats you like. You could use a simple string format or a binary format like protocol buffers.","title":"Create a new subclass of Enclave"},{"location":"writing-hello-world.html#write-a-simple-host-program","text":"An enclave by itself is just a library: you must therefore load it from inside a host program. It's easy to load then pass data to and from an enclave. Let's start with the skeleton of a little command line app: 1 2 3 4 5 6 7 8 9 10 11 12 /** * This class demonstrates how to load an enclave and use it. */ public class Host { public static void main ( String [] args ) throws EnclaveLoadException { // TODO: Fill this out } public static String callEnclave ( EnclaveHost enclave , String input ) { // TODO: Fill this out. } } At first we will be building and running our enclave in simulation mode. This does not require the platform hardware to support SGX. However simulation mode does require us to be using Linux. If we are not using Linux as our host OS then we can use a Linux container or virtual machine. Alternatively we could use mock mode instead of simulation mode. When we want to switch to loading either a debug or release build of the enclave we need to ensure the platform supports SGX. By adding the code below to the main method we can determine whether the platform can load debug and release enclaves. This method reports the actual hardware status even if you are currently working with simulation enclaves. If SGX is not supported the function throws an exception which describes the reason why. There are a number of common reasons why SGX may not be supported including: The CPU or the system BIOS does not support SGX. The host operating system is Windows or Mac OS. Conclave currently only supports loading enclaves in simulation, debug or release modes on Linux. SGX is disabled in the BIOS and must be manually enabled by the user. SGX is disabled but can be enabled in software. If SGX is disabled but can be enabled in software the code below attempts to automatically enable SGX support by specifying the 'true' parameter. It might be necessary to run this application with root access and/or reboot the system in order to successfully enable SGX. The exception message will describe if this is the case. 1 2 3 4 5 6 try { EnclaveHost . checkPlatformSupportsEnclaves ( true ); System . out . println ( \"This platform supports enclaves in simulation, debug and release mode.\" ); } catch ( EnclaveLoadException e ) { System . out . println ( \"This platform does not support hardware enclaves: \" + e . getMessage ()); } To load the enclave we'll put this after the platform check: 1 2 3 4 5 6 7 8 9 String className = \"com.r3.conclave.sample.enclave.ReverseEnclave\" ; try ( EnclaveHost enclave = EnclaveHost . load ( className )) { enclave . start ( null , null ); System . out . println ( callEnclave ( enclave , \"Hello world!\" )); // !dlrow olleH :-) // TODO: Get the remote attestation } This code starts by creating an EnclaveHost object. This names the class and then attempts to load it inside another JVM running inside an enclave. A remote attestation procedure is then performed involving Intel's servers. This procedure can fail if attempting to load a debug or release enclave and the platform does not support SGX. This is why it is important to perform the platform check we made in the code above. If the enclave does fail to load for any reason then an exception is thrown describing the reason why. We then call start which initialises the enclave and the MyEnclave class inside it. You can load multiple enclaves at once but they must all use same mode, and each enclave will get its own isolated JVM. Note that an EnclaveHost allocates memory out of a pool called the \"enclave page cache\" which is a machine-wide limited resource. It'll be freed if the host JVM quits, but it's good practice to close the EnclaveHost object by calling close on it when done. Therefore we also make sure the .close() method is called on the enclave no matter what using a try-with-resources statement. This doesn't actually matter in such a tiny hello world sample, because the enclave will be unloaded by the kernel once we exit like any other resource. It's just here to remind you that an enclave must be explicitly unloaded if you need to reinitialise it for whatever reason, or if you need the memory back. Warning Starting and stopping/closing an enclave is not free, so don't load the enclave, use it and immediately close it again as in the above example. Cost-wise it's like starting a regular process even though no process will actually exist. Treat the enclave like any other expensive resource and keep it around for as long as you might need it. Once we started the enclave, we call it passing in a string as bytes. The enclave will reverse it and we'll print out the answer. This is as easy as calling EnclaveHost.callEnclave , so put this in the callEnclave static method defined above: 1 2 // We'll convert strings to bytes and back. return new String ( enclave . callEnclave ( input . getBytes ())); So we just convert the string to bytes, send it to the enclave, and convert the response from bytes back to a string.","title":"Write a simple host program"},{"location":"writing-hello-world.html#remote-attestation","text":"There's no point in using an enclave to protect purely local data, as the data must ultimately come from the (assumed malicious/compromised) host in that scenario. That's why you need remote attestation, which lets an enclave prove its identity to the third parties who will upload secret data. If this paragraph doesn't make sense please review the Architecture overview and the enclaves section. Before we can set up communication with a client, we must therefore get remote attestation working. Using remote attestation is easy! Just obtain an EnclaveInstanceInfo and serialize/deserialize it using the provided methods. There's a useful toString method: 1 2 3 final EnclaveInstanceInfo attestation = enclave . getEnclaveInstanceInfo (); final byte [] attestationBytes = attestation . serialize (); System . out . println ( EnclaveInstanceInfo . deserialize ( attestationBytes )); That will print out something like this: 1 2 3 4 5 6 7 8 9 10 Remote attestation for enclave F86798C4B12BE12073B87C3F57E66BCE7A541EE3D0DDA4FE8853471139C9393F: - Mode: SIMULATION - Code signing key hash: 01280A6F7EAC8799C5CFDB1F11FF34BC9AE9A5BC7A7F7F54C77475F445897E3B - Public signing key: 302A300506032B65700321000568034F335BE25386FD405A5997C25F49508AA173E0B413113F9A80C9BBF542 - Public encryption key: A0227D6D11078AAB73407D76DB9135C0D43A22BEACB0027D166937C18C5A7973 - Product ID: 1 - Revocation level: 0 Assessed security level at 2020-07-17T16:31:51.894697Z is INSECURE - Enclave is running in simulation mode. The hash in the first line is the measurement . This is a hash of the code of the enclave. It includes both all the Java code inside the enclave as a fat-JAR, and all the support and JVM runtime code required. As such it will change any time you alter the code of your enclave, the version of Conclave in use or the mode (simulation/debug/release) of the enclave. The enclave measurement should be stable across builds and machines, so clients can audit the enclave by repeating the Gradle build and comparing the value they get in the EnclaveInstanceInfo against what the build process prints out. Tip All this data is available via individual getters on the EnclaveInstanceInfo so you should never feel a need to parse the output of toString . EnclaveInstanceInfo is an interface so you can easily build mock attestations in your tests. When not in simulation mode the timestamp is signed by Intel and comes from their servers. An instance has a security assessment, which can change in response to discovery of vulnerabilities in the infrastructure (i.e. without anything changing about the host or enclave itself). As we can see this enclave isn't actually considered secure yet because we're running in simulation mode still. An enclave can be SECURE , STALE , or INSECURE . A assessment of STALE means there is a software/firmware/microcode update available for the platform that improves security in some way. The client may wish to observe when this starts being reported and define a time span in which the remote enclave operator must upgrade. Now get the serialized bytes to a client via whatever network mechanism you want. The bytes are essentially a large, complex digital signature, so it's safe to publish them publicly. An attestation doesn't inherently expire but because the SGX ecosystem is always moving, client code will typically have some frequency with which it expects the host code to refresh the EnclaveInstanceInfo . At present this is done by stopping/closing and then restarting the enclave.","title":"Remote attestation"},{"location":"writing-hello-world.html#configurating-attestation","text":"To use SGX remote attestation for real we need to do some additional work. Remember how we wrote enclave.start(null, null); above? The first parameter contains configuration data required to use an attestation service. There are three kinds of attestation service: EPID. This older protocol is supported by some desktop/laptop class Intel CPUs. The EPID protocol includes some consumer privacy cryptography, and involves talking directly to Intel's IAS service to generate an attestation. For that you need to obtain an API key and service provider ID from Intel. You can sign-up easily and for free. Learn more about IAS . Azure DCAP. The datacenter attestation primitives protocol is newer and designed for servers. When running on a Microsoft Azure Confidential Compute VM or Kubernetes pod, you don't need any parameters. It's all configured out of the box. Generic DCAP. When not running on Azure, you need to obtain API keys for Intel's PCCS service. We'll target Azure for now to keep things simple. Replace the call to EnclaveHost.start above with this snippet: 1 enclave . start ( new AttestationParameters . DCAP (), null ); Info Why does Conclave need to contact Intel's servers? It's because those servers contain the most up to date information about what CPUs and system enclave versions are considered secure. Over time these servers will change their assessment of the host system and this will be visible in the responses, as security improvements are made.","title":"Configurating attestation"},{"location":"writing-hello-world.html#run-what-weve-got-so-far","text":"We can apply the Gradle application plugin and set the mainClassName property in the usual manner to let us run the host from the command line. Now run gradlew host:run and it should print \"Hello World!\" backwards along with the security info as shown above. During the build you should see output like this: 1 2 3 > Task :enclave:generateEnclaveletMetadataSimulation Succeed. Enclave measurement: 04EDA32215B496C3890348752F47D77DC34989FE4ECACCF5EC5C054F1D68BBE6 The measurement should correspond to the value found in the EnclaveInstanceInfo.getCodeHash() property. You can switch to debug mode by specifying the enclaveMode property. In debug mode the real hardware is used and virtually everything is identical to how it will be in production, but there's a small back door that can be used by debuggers to read/write the enclave's memory. You will need to run this on an Azure Confidential VM . gradlew -PenclaveMode=debug host:run","title":"Run what we've got so far"},{"location":"writing-hello-world.html#encrypted-messaging","text":"The enclave isn't of much use to the host, because the host already trusts itself. It's only useful to remote clients that want to use the enclave for computation without having to trust the host machine or software. We're now going to wire up encrypted messaging. Conclave provides an API for this called Mail. Conclave Mail handles all the encryption for you, but leaves it up to you how the bytes themselves are moved around. You could use a REST API, a gRPC API, JMS message queues, a simple TCP socket as in this tutorial, or even files. Info Learn more about the design of Conclave Mail , and compare it to TLS .","title":"Encrypted messaging"},{"location":"writing-hello-world.html#receiving-and-posting-mail-in-the-enclave","text":"Firstly we need to upgrade our little enclave to be able to receive mails from clients. This is easy! Just override the receiveMail method: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /** * Simply reverses the bytes that are passed in. */ public class ReverseEnclave extends Enclave { @Override public byte [] receiveFromUntrustedHost ( byte [] bytes ) { byte [] result = new byte [ bytes . length ] ; for ( int i = 0 ; i < bytes . length ; i ++ ) { result [ i ] = bytes [ bytes . length - 1 - i ] ; } return result ; } @Override protected void receiveMail ( long id , EnclaveMail mail ) { byte [] reversed = receiveFromUntrustedHost ( mail . getBodyAsBytes ()); MutableMail reply = createMail ( mail . getAuthenticatedSender (), reversed ); postMail ( reply , null ); } } The receiveFromUntrustedHost method here isn't really needed, it's just because we're already using this to demonstrate local calls. The new part is receiveMail . This method takes two parameters: an identifier that the host gets to pick, which doesn't mean anything but we can use to acknowledge the mail if we want to using Enclave.acknowledgeMail . Acknowledgement can be used to tell the host the enclave is done processing the mail if it doesn't want to reply immediately. It will be discussed more in future tutorials. In this simple tutorial we reply immediately so don't need to use this feature, and thus we ignore the ID. The second parameter is an EnclaveMail . This object gives us access to the body bytes that the client sent, but it also exposes some other header fields: The authenticated sender public key . This is the public key of the client that sent the mail. It's called \"authenticated\" because the encryption used by Conclave means you can trust that the mail was encrypted by an entity holding the private key matching this public key. If your enclave recognises the public key this feature can be used as a form of user authentication. A topic . This can be used to distinguish between different streams of mail from the same client. It's a string and can be thought of as equivalent to a URL path or port number. The from field . This is a string that the sender can pick to identify itself. Unlike the authenticated sender key this is entirely arbitrary, and nothing stops a sender picking any value it likes. Often this field won't be used. It's intended to hold some sort of routing address where the sender would like to receive replies - sometimes this is implied, but an explicit routing address can be useful when implementing more complex hosts and enclave that may not reply straight away. The envelope . This is a slot that can hold any arbitrary byte array the sender likes. It's a holding zone for app specific data that should be authenticated but unencrypted. The sequence number . This must increment by one for every mail delivered on a topic. Conclave will automatically reject messages for which this doesn't hold true, within the scope of messages seen whilst the enclave is loaded. These header fields are available to the host and therefore should not contain secrets . It may seem odd to have data that's unencrypted, but it's often useful for the client, host and enclave to collaborate in various ways related to storage and routing of data. Even when the host is untrusted it may still be useful for the client to send data that is readable by the host and enclave simultaneously, but which the host cannot tamper with. Inside the enclave you can be assured that the header fields contain the values set by the client, because they're checked before receiveMail is invoked. In this simple tutorial we only care about the body and sender public key. We reverse the bytes in the mail body and then create a response mail that will be encrypted to the sender. It contains the reversed bytes. We use the createMail method to do this. It gives us back a MutableMail object, which is a builder with setters we can use to control the sequence number, topic and so on. Once we've done configuring it to our liking we pass it to postMail which performs the encryption and delivers the newly encrypted mail to the host. It will emerge in a callback we're about to configure. Tip You can post mail anytime and to anyone you like. It doesn't have to be a response to the sender, you can post multiple mails at once and you can post mails inside receiveFromUntrustedHost (i.e. during a local call).","title":"Receiving and posting mail in the enclave"},{"location":"writing-hello-world.html#receiving-and-posting-mail-in-the-host","text":"Mail posted by an enclave appears in a callback we pass to EnclaveHost.start . Let's use a really simple implementation: we'll just store the encrypted bytes in a variable, so we can pick it up later: 1 2 3 4 5 6 7 8 // Start it up. AtomicReference < byte []> mailToSend = new AtomicReference <> (); enclave . start ( attestationParameters , new EnclaveHost . MailCallbacks () { @Override public void postMail ( byte [] encryptedBytes , String routingHint ) { mailToSend . set ( encryptedBytes ); } }); Java doesn't let us directly change variables from a callback, so we use an AtomicReference here as a box. Tip Kotlin lets you alter mutable variables from callbacks directly, without needing this sort of trick. The enclave can provide a routing hint to tell the host where it'd like the message delivered. For example, this could be set to the value of the from header. It's called a \"hint\" because the enclave must always remember that the host is untrusted. It can be arbitrarily malicious and could, for example, not deliver the mail at all, or it could deliver it to the wrong place. However if it does deliver it wrongly, the encryption will ensure the bogus recipient can't do anything with the mail. In this simple hello world tutorial we can only handle one client at once so we're going to ignore the routing hint here. In a more sophisticated server you could provide an implementation of EnclaveHost.MailCallbacks that has access to your connected clients, a database, a durable queue, a ThreadLocal containing a servlet connection and so on. At the bottom of our main method let's add some code to accept TCP connections and send the EnclaveInstanceInfo to whomever connects. Then we'll accept a mail uploaded by the client, send it to the enclave, and deliver the response back. We'll write the client code in a moment. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 int port = 9999 ; System . out . println ( \"Listening on port \" + port + \". Use the client app to send strings for reversal.\" ); ServerSocket acceptor = new ServerSocket ( port ); Socket connection = acceptor . accept (); // Just send the attestation straight to whoever connects. It's signed so that's MITM-safe. DataOutputStream output = new DataOutputStream ( connection . getOutputStream ()); output . writeInt ( attestationBytes . length ); output . write ( attestationBytes ); // Now read some mail from the client. DataInputStream input = new DataInputStream ( connection . getInputStream ()); byte [] mailBytes = new byte [ input . readInt () ] ; input . readFully ( mailBytes ); // Deliver it. The enclave will give us some mail to reply with via the callback we passed in // to the start() method. enclave . deliverMail ( 1 , mailBytes , \"routingHint\" ); byte [] toSend = mailToSend . getAndSet ( null ); output . writeInt ( toSend . length ); output . write ( toSend ); This code is straightforward. In order, it: Opens a socket using the Java sockets API and listens for a connection. Accepts a connection and then sends the serialized EnclaveInstanceInfo to the client. We first send the length so the client knows how many bytes to read. The client will send us a byte array back, which contains an encrypted string. This code can't read the body, it's just encrypted bytes except for a few fields in the headers, which are available to the host. We deliver the encrypted mail bytes to the enclave. We pick up the response from the AtomicReference box that was set by the callback. The first parameter to deliverMail is a \"mail ID\" that the enclave can use to identify this mail to the host. This feature is intended for use with acknowledgement, which allows the enclave to signal that it's done with that message and the work it represents can be atomically/transactionally completed. The routing hint is an arbitrary string that can be used to identify the sender of the mail from the host's perspective, e.g. a connection ID, username, identity - it's up to you. The enclave can use this string to signal to the host that a mail should go to that location. It's called a \"hint\" to remind you that the host code may be modified or writter by an attacker, so the enclave can't trust it. However, the encryption on the mail makes it useless for the host to mis-direct mail. Todo In future we will provide APIs to bind enclaves to common transports, to avoid this sort of boilerplate.","title":"Receiving and posting mail in the host"},{"location":"writing-hello-world.html#writing-the-client","text":"The client app will do three things: Connect to the host server and download the EnclaveInstanceInfo from it. Verify the enclave is acceptable: i.e. that it will do what's expected. Send it the command line arguments as a string to reverse and get back the answer, using encrypted mail. Here's the initial boilerplate to grab the user input, connect, download and deserialize the EnclaveInstanceInfo . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Client { public static void main ( String [] args ) throws IOException , InvalidEnclaveException { if ( args . length == 0 ) { System . err . println ( \"Please pass the string to reverse on the command line\" ); return ; } String toReverse = String . join ( \" \" , args ); // Connect to the host, it will send us a remote attestation (EnclaveInstanceInfo). Socket socket = new Socket ( \"localhost\" , 9999 ); DataInputStream fromHost = new DataInputStream ( socket . getInputStream ()); byte [] attestationBytes = new byte [ fromHost . readInt () ] ; fromHost . readFully ( attestationBytes ); EnclaveInstanceInfo attestation = EnclaveInstanceInfo . deserialize ( attestationBytes ); } }","title":"Writing the client"},{"location":"writing-hello-world.html#constraints","text":"How do you know the EnclaveInstanceInfo you've got is for the enclave you really intend to interact with? In normal client/server programming you connect to a host using some sort of identity, like a domain name or IP address. TLS is used to ensure the server that picks up is the rightful owner of the domain name you intended to connect to. In enclave programming the location of the enclave might not matter much because the host is untrusted. Instead you have to verify what is running, rather than where it's running. Note The domain name of the server can still be important in some applications, in which case you should use TLS instead of raw sockets as is the case here. One way to do this is by inspecting the properties on the EnclaveInstanceInfo object and hard-coding some logic. That works fine, but testing an EnclaveInstanceInfo is a common pattern in enclave programming, so we provide an API to do it for you. The EnclaveConstraint class takes an EnclaveInstanceInfo and performs some matching against it. A constraint object can be built in code, or it can be loaded from a small domain specific language encoded as a one-line string. The string form is helpful if you anticipate frequent upgrades that should be whitelisted or other frequent changes to the acceptable enclave, as it can be easily put into a configuration file, JSON, XML or command line flags. The constraint lets you specify: Acceptable code hashes (measurements) Acceptable signing public keys The minimum revocation level The product ID The security level of the instance: SECURE , STALE , INSECURE If you specify a signing public key then you must also specify the product ID, otherwise if the organisation that created the enclave makes a second different kind of enclave in future, a malicious host might connect you with the wrong one. If the input/output commands are similar then a confusion attack could be opened up. That's why you must always specify the product ID even if it's zero. The simplest possible string-form constraint looks like this: C:F86798C4B12BE12073B87C3F57E66BCE7A541EE3D0DDA4FE8853471139C9393F It says \"accept exactly one program, with that measurement hash\". In this case the value came from the output of the build process as shown above. This is useful when you don't trust the author nor host of the enclave, and want to audit the source code and then reproduce the build. Often that's too rigid. We trust the developer of the enclave, just not the host. In that case we'll accept any enclave signed by the developer's public key. We can express that by listing code signing key hashes, like this: S:01280A6F7EAC8799C5CFDB1F11FF34BC9AE9A5BC7A7F7F54C77475F445897E3B PROD:1 When constraining to a signing key we must also specify the product ID, because a key can be used to sign more than one product. 1 2 3 // Check it's the enclave we expect. This will throw InvalidEnclaveException if not valid. // The hash here comes from observing what the build printed. EnclaveConstraint . parse ( \"S:01280A6F7EAC8799C5CFDB1F11FF34BC9AE9A5BC7A7F7F54C77475F445897E3B PROD:1 SEC:INSECURE\" ). check ( attestation ); This line of code parses a simple constraint that says any enclave (even if run in simulation mode) signed by this hash of a code signing key with product ID of 1 is acceptable. Obviously in a real app, you would remove the part that says SEC:INSECURE , but it's convenient to have this whilst developing. You'd probably also retrieve the constraint from a configuration file, system property or command line flag. Finally it uses the check method with the attestation object. If anything is amiss an exception is thrown, so past this point we know we're talking to the real ReverseEnclave we wrote earlier.","title":"Constraints"},{"location":"writing-hello-world.html#keys-and-mail","text":"We want to receive a response from the enclave, and we want that to be encrypted/tamperproofed too. That means we need a key pair of our own. Conclave uses Curve25519, a state of the art elliptic curve algorithm. For reasons of implementation robustness and avoidance of side channel attacks, this is the only algorithm supported by Conclave Mail. If you want to use other algorithms for some reason you would need to implement your own messaging system on top of host-local calls. Alternatively, use that other algorithm to encrypt/decrypt a Curve25519 private key. Generating such a key is straightforward: 1 KeyPair myKey = new Curve25519KeyPairGenerator (). generateKeyPair (); Unfortunately the Java Cryptography Architecture only introduced official support for Curve25519 in Java 11. At the moment in Conclave therefore, you must utilize our Curve25519KeyPairGenerator , Curve25519PublicKey and Curve25519PrivateKey classes. In future we may offer support for using the Java 11 JCA types directly. A Curve25519 private key is simply 32 random bytes, which you can access using the getEncoded() method on PrivateKey . Now we have a key with which to receive the response, we create a mail to the enclave. This is done using the EnclaveInstanceInfo.createMail method, which returns a MutableMail object. We must set our private key on the mail so it's mixed in to the calculations when the mail is encrypted and thus becomes available in getAuthenticatedSender() inside the enclave: without the call to setPrivateKey the authenticated sender will be null. This can sometimes be appropriate, if for example, the enclave already knows the sender's private key via some other mechanism. The sequence number for this newly created mail is zero. That means if we re-run the program twice we'll try to send the enclave two mails with the same topic, sender and sequence number. This is invalid: the enclave will reject it as an apparent replay attack until it's restarted and forgets what mail it received. We could keep a counter on disk and increment it, but it's easier to simply set the topic to a random UUID. After that, we can encrypt the mail. 1 2 3 4 5 MutableMail mail = attestation . createMail ( toReverse . getBytes ( StandardCharsets . UTF_8 )); mail . setPrivateKey ( myKey . getPrivate ()); // Set a random topic, so we can re-run this program against the same server. mail . setTopic ( UUID . randomUUID (). toString ()); byte [] encryptedMail = mail . encrypt (); In more complex apps it might be smart to use the topic in more complex ways, like how a web app can use the URL to separate different functions of the app. Now we have an encrypted message we can write it to the socket and receive the enclave's response. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 System . out . println ( \"Sending the encrypted mail to the host.\" ); DataOutputStream toHost = new DataOutputStream ( socket . getOutputStream ()); toHost . writeInt ( encryptedMail . length ); toHost . write ( encryptedMail ); // Enclave will mail us back. byte [] encryptedReply = new byte [ fromHost . readInt () ] ; System . out . println ( \"Reading reply mail of length \" + encryptedReply . length + \" bytes.\" ); fromHost . readFully ( encryptedReply ); // Decrypt the reply EnclaveMail reply = attestation . decryptMail ( encryptedReply , myKey . getPrivate ()); System . out . println ( \"Enclave reversed '\" + toReverse + \"' and gave us the answer '\" + new String ( reply . getBodyAsBytes ()) + \"'\" ); socket . close (); We write out the length of the mail, then the mail bytes, then read the length of the response and read the response bytes. Finally we use EnclaveInstanceInfo.decryptMail , passing in the encrypted reply we got and our own private key. This method checks the bytes really did come from that enclave (by checking the authenticated sender key against the enclave's public key in the attestation), decodes the bytes and yields the reply. We can then access the body of the message using EnclaveMail.getBodyAsBytes() . Finally we close the socket, and we're done. Phew! \ud83d\ude05","title":"Keys and mail"},{"location":"writing-hello-world.html#testing","text":"There are two ways you can test the enclave: as a mock or natively.","title":"Testing"},{"location":"writing-hello-world.html#mock","text":"The conclave-testing library has a MockHost class which lets you whitebox test your enclave by running the enclave fully in-memory. There is no need for SGX hardware or a specific OS and thus ideal for cross-platform unit testing. The underlying enclave object is also exposed enabling you to make assertions on the enclave's state, something that cannot be done on real hardware or even in simulation mode. In your enclave module add the following test dependency 1 testImplementation \"com.r3.conclave:conclave-testing\" You create your mock enclave by calling MockHost.loadMock . 1 2 3 MockHost < ReverseEnclave > mockHost = MockHost . loadMock ( ReverseEnclave . class ); mockHost . start ( null , null , null ); ReverseEnclave reverseEnclave = mockHost . getEnclave (); MockHost is a EnclaveHost so you call the enclave as normal with callEnclave . You have direct assess to the enclave object instance with mockHost.getEnclave() .","title":"Mock"},{"location":"writing-hello-world.html#native","text":"Testing the enclave natively is relatively straightforward: the enclave needs to be loaded with EnclaveHost.load . By default this will run the tests in a simulated environment and will require the correct OS. Native tests are ideal for integration testing. To test the enclave in debug mode on real secure hardware the -PenclaveMode=debug flag needs to be specified and the SPID and attestation key need to be passed into the test. This can be done with system properties. In your host module build file: 1 2 3 4 5 test { useJUnitPlatform () // Pass through any -Pspid and -Pattestation-key parameters to the tests systemProperties project . properties . subMap ([ \"spid\" , \"attestation-key\" ]) } Pass these values to EnclaveHost.start in your test: 1 2 3 4 5 6 7 private static EnclaveHost enclave ; @BeforeAll static void startup () throws EnclaveLoadException { enclave = EnclaveHost . load ( \"com.r3.conclave.sample.enclave.ReverseEnclave\" ); enclave . start ( new AttestationParameters . DCAP (), null ); } gradlew -PenclaveMode=debug host:test Note that native tests are located in the host module while mock tests in the enclave module.","title":"Native"}]}